<html><head></head><body><div id="d4h5-main-container" class="dk-main"><section id="loio15d74a2d274a4d8abc57c5d31fe2deb5" class=" section topic"><div class="section-mdeditlink hidden">
				<a class="mdeditlink hidden" href="https://github.com/SAP-docs/sapui5/blob/main/docs/09_Developing_Controls/synchronizing-controls-15d74a2.md">Edit on GitHub</a>
			</div><div class="collapsible-icon sap-icon innerTitle"><h2 class="title ">Synchronizing Controls</h2></div><div class="fig"><div class="topictitle1 title"><h2 class="title ">Synchronizing Controls</h2></div><div class="shortdesc">Here's how you can keep properties, aggregations, and events synchronized when using the <cite>combine</cite> action.</div><section id="section_bqt_4kt_hyb">
			<h2 class="title ">Synchronizing Properties</h2>
			<p>While applying the <cite>combine</cite> change, we sometimes need to create new controls. Like in the previous example, we create a
					<code>sap.m.MenuItem</code> control for each original instance of <code>sap.m.Button</code>. The original button can have
				bindings on certain properties. For example, the <code>enabled/text/visible</code> properties can be bound to a custom model. When
				the bound model changes, the original control reacts accordingly. The same behavior should be inherited by newly created controls (in
				our case <code>sap.m.MenuItem</code>).</p>
			<p><span class="emphasis">Example:</span> If the enabled property changes in the model, the original button receives this change. The newly created
					<code>sap.m.MenuItem</code> control, which corresponds to this button, should also receive this change on the
					<code>enabled</code> property and should disable/enable the new button accordingly.</p>
			<p>Here's a solution: The <code>sap.ui.fl</code> library provides a special object called <code>sap.ui.fl.util.ManagedObjectModel</code>.
				It's a wrapper of <code>sap.ui.model.base.ManagedObjectModel</code>. You can use this object to express the desired
				synchronization logic between two controls in a declarative way that works on JavaScript and XML level. Here's how:</p>
			<div class="note other samplecode "><div class="collapsible-icon sap-icon"><div class="title"><strong>
					Sample Code
				</strong></div></div><div class="fig"><p>Example of
					<code>sap.ui.fl.util.ManagedObjectModel</code> usage for properties
				synchronization
				</p><section><div class="fig fig-codeblock"><div class="copyButton"><span style="display: none;">Hidden</span></div><div class="codeblock-wrapper"><pre class="codeblock">// Model name can be any string, but we recommend to use the following pattern to simplify debugging in case of problems:
var sModelName = "$sap.m.flexibility.CombineButtonsModel";
 
// Like any other new control, we ask Modifier to create it for us.
var oManagedObjectModel = oModifier.createControl(
    "sap.ui.fl.util.ManagedObjectModel",
    oAppComponent,
    oView,
    Object.assign({}, oSelector, {
        id: oSelector.id + '-managedObjectModel' // Make sure this control has a unique ID.
    }),
    {
        object: oButton, // Object against which this model is going to be created.
        name: sModelName
    }
);
 
// Insert the newly created model into the `dependents` aggregation of the control where this model is going to be used.
oModifier.insertAggregation(oMenuItem, "dependents", oManagedObjectModel);
 
// ** IMPORTANT ** DO NOT CALL .setModel() setter on the control, because it cannot be expressed
// declaratively on XML level. The setModel() will be called automatically by sap.ui.fl.util.ManagedObjectModel
// when it is added to the desired control. That said, after the next line, the oMenuItem already has the model set.
 
// Create binding against newly created model. The model object automatically subscribes to updates
// for the property with the same name in the original object (oButton in this code sample).
oModifier.bindProperty(oMenuItem, "text", sModelName + "&gt;/text");</pre></div></div></section><p></p></div></div>
            <div class="note tip  "><div class="collapsible-icon sap-icon"><div class="title"><strong>
					Tip
				</strong></div></div><div class="fig"><p>
                </p><p>Find a full example on GitHub at <a href="https://github.com/SAP/openui5/blob/master/src/sap.m/src/sap/m/changeHandler/CombineButtons.js" title="https://github.com/SAP/openui5/blob/master/src/sap.m/src/sap/m/changeHandler/CombineButtons.js" class="external-link" target="_blank" rel="noopener">https://github.com/SAP/openui5/blob/master/src/sap.m/src/sap/m/changeHandler/CombineButtons.js</a>.</p>
            <p></p></div></div>
			<p>Thanks to the abstraction of <code>sap.ui.fl.util.ManagedObjectModel</code>, we don't have to worry if the original control has bindings or
				not. This complexity is hidden inside <code>ManagedObjectModel</code> itself. <code>ManagedObjectModel</code> lets us simply
				watch properties changes on some control without having to think about implementation details.</p>
		</section><section id="section_kry_c4t_hyb">
			<h2 class="title ">Synchronizing Aggregations</h2>
			<p>The original control sometimes has a <code>customData</code> aggregation with some data in it, which has to be available from the newly
				created control as well. In our example: If the <code>sap.m.Button</code> has a <code>customData</code> aggregation, the same
				data should be available on <code>sap.m.MenuItem</code>, which corresponds to this button.</p>
			<p>Here's a solution: By using <code>sap.ui.fl.util.ManagedObjectModel</code>, it's also possible to synchronize aggregations. Refer to the
				previous code snippet on how to create the <code>ManagedObjectModel</code> instance. Here's an example on how to bind an
				aggregation:</p>
			<div class="note other samplecode "><div class="collapsible-icon sap-icon"><div class="title"><strong>
					Sample Code
				</strong></div></div><div class="fig"><p>Example of <code>sap.ui.fl.util.ManagedObjectModel</code> usage for properties synchronization
				</p><section><div class="fig fig-codeblock"><div class="copyButton"><span style="display: none;">Hidden</span></div><div class="codeblock-wrapper"><pre class="codeblock">// Create an aggregation binding on customData aggregation on a newly created control (sap.m.MenuItem).
oModifier.bindAggregation(oMenuItem, "customData", {
    path: sModelName + "&gt;/customData", // Binding path points to the customData property of the model which points to the customData aggregation on the original control.
    template: oModifier.createControl( // Template specifies how data should be translated into the receiver control.
        "sap.ui.core.CustomData",
        oAppComponent,
        oView,
        Object.assign({}, oSelector, { // Make sure the template has a unique ID. The rows in the bound aggregation will use this ID plus postfix - "-clone-{i}", where "i" is a row number.
            id: oSelector.id + '-customData'
        }),
        {
            key: {
                path: sModelName + "&gt;key" // Binding for `key` property against the CustomData instance on original control
            },
            value: {
                path: sModelName + "&gt;value" // Binding for `value` property against the CustomData instance on original control
            }
        }
    )
});
</pre></div></div></section><p></p></div></div>
		</section><section id="section_h3d_1pt_hyb">
			<h2 class="title ">Synchronizing Events</h2>
			<p>The original control sometimes has some event handlers attached to it, and these event handlers have to be called. In our example, the original
					<code>sap.m.Button</code> has a press event handler attached. When the newly created control is clicked, the event handler on
				the original control has to be called as well.</p>
			<p>Here's how to do this:</p>
			<ol>
				<li class="li">
					<p>Make sure that the AMD module of the change handler is exported to the global namespace:</p>
					<div class="note other samplecode "><div class="collapsible-icon sap-icon"><div class="title"><strong>
					Sample Code
				</strong></div></div><div class="fig"><p>Snippet indicating how to expose the AMD module into global
						namespace</p><section><div class="fig fig-codeblock"><div class="copyButton"><span style="display: none;">Hidden</span></div><div class="codeblock-wrapper"><pre class="codeblock">sap.ui.define(function () {
    "use strict";
 
    var CombineButtons = {};
    // Implementation
    return CombineButtons;
 
}, /* bExport= */true); // &lt;&lt;&lt;--- IMPORTANT: Must be `true`.</pre></div></div></section><p></p></div></div>
				</li>
				<li class="li">
					<p>Create an event handler function inside the change handler. This is called a proxy handler. This proxy function is going to be attached to the
						newly created control and is responsible to trigger the corresponding event on the original control. Here's an example:</p>
					<div class="note other samplecode "><div class="collapsible-icon sap-icon"><div class="title"><strong>
					Sample Code
				</strong></div></div><div class="fig"><p>Snippet demonstrating how to define a proxy event
						handler</p><section><div class="fig fig-codeblock"><div class="copyButton"><span style="display: none;">Hidden</span></div><div class="codeblock-wrapper"><pre class="codeblock">sap.ui.define([
    "sap/ui/core/util/reflection/JsControlTreeModifier"
], function (
    JsControlTreeModifier
) {
    "use strict";
 
    var CombineButtons = {};
 
    /**
     * Callback function which is attached via modifier in applyChange
     * @param {sap.ui.base.Event} oEvent - Event object
     * @param {object} mSelector - Selector object
     * @param {string} mSelector.id - ID used for determination of the flexibility target
     * @param {boolean} mSelector.idIsLocal - Flag if the selector.id has to be concatenated with the application component ID while applying the change.
     */
    CombineButtons.pressHandler = function (oEvent, mSelector) {
        var oButton = JsControlTreeModifier.bySelector(mSelector);
        oButton.firePress(); // The proxy handler is responsible to pass any parameters from oEvent object to firePress() call of the original control.
    };
 
    return CombineButtons;
}, /* bExport= */true);</pre></div></div></section><p></p></div></div>
					<div class="note   "><div class="collapsible-icon sap-icon"><div class="title"><strong>
					Note
				</strong></div></div><div class="fig"><p>
						</p><p>The proxy function receives the payload object as a second parameter, which contains the information about the original control. It's a
							standard feature of SAPUI5 that event handlers can receive some
							payload in addition to a classic <code>sap.ui.base.Event</code> object. However, this doesn't happen automatically,
							the change handler developer needs to bypass this parameter when attaching the event (see next step).</p>
					<p></p></div></div>
					<div class="note   "><div class="collapsible-icon sap-icon"><div class="title"><strong>
					Note
				</strong></div></div><div class="fig"><p>
						</p><p>As no actual events can happen on XML level, it's safe to use <code>JsControlTreeModifier</code> inside the proxy event handler. Commonly
							it's used to get a control instance out of a selector object.</p>
					<p></p></div></div>
				</li>
				<li class="li">
					<p>Attach the created proxy handler to newly created control: </p>
					<div class="note other samplecode "><div class="collapsible-icon sap-icon"><div class="title"><strong>
					Sample Code
				</strong></div></div><div class="fig"><p>Snippet demonstrating how to define a proxy event
						handler</p><section><div class="fig fig-codeblock"><div class="copyButton"><span style="display: none;">Hidden</span></div><div class="codeblock-wrapper"><pre class="codeblock">oModifier.attachEvent(oMenuItem, "press", "sap.m.changeHandler.CombineButtons.pressHandler", oModifier.getSelector(oButton, oAppComponent));
</pre></div></div></section><p></p></div></div>
					<div class="note   "><div class="collapsible-icon sap-icon"><div class="title"><strong>
					Note
				</strong></div></div><div class="fig"><p>
						</p><p>It's important to pass a string that defines a path to the proxy handler. The reason behind it is XML support. For the original control, it's
							recommended to pass a Selector object. </p>
					<p></p></div></div>
				</li>
			</ol>
		</section><section class="contentInSection hidden"><h2>In this section:</h2></section><section class="familyLinks"><div class="parentLink"><br><strong>Parent topic: </strong><a href="topic/12a2d5d90fbd478faaac4029c76de473">Enabling the Combine Action</a></div><div class="previousLink"><br><strong>Previous: </strong><a href="topic/51f589b65e9642c4949639fdb995257a">Provide the Design-Time Metadata for the Combine Action</a></div><div class="nextLink hidden"><br><strong>Next: </strong></div></section><section class="hidden relatedLinks "><div class="collapsible-icon sap-icon title"><h2>Related information</h2></div><ul class="fig"></ul></section></div></section></div></body></html>