{"version":3,"file":"BuildingBlockTemplateProcessor.js","names":["LOGGER_SCOPE","XMLTEMPLATING_NS","DOMParserInstance","DOMParser","validateMacroMetadataContext","sName","mContexts","oContextSettings","sKey","oContext","oContextObject","getObject","required","Error","hasOwnProperty","$kind","undefined","expectedTypes","includes","getPath","$Type","expectedAnnotationTypes","validateMacroSignature","oMetadata","oNode","aMetadataContextKeys","metadataContexts","Object","keys","aProperties","properties","oAttributeNames","attributeNames","getAttributeNames","attributeName","forEach","oPropertySettings","hasAttribute","startsWith","Log","warning","_exports","SAP_UI_CORE_ELEMENT","SAP_UI_MODEL_CONTEXT","transformMetadata","buildingBlockMetadata","class","type","isPublic","aggregations","dependents","slot","customData","layoutData","propertyName","propertyType","_checkAbsoluteAndContextPaths","oSettings","sAttributeValue","sMetaPath","sContextPath","currentContextPath","endsWith","model","path","_createInitialMetadataContext","sAttributeName","returnContext","models","converterContext","getProperty","data","unstoreObjectValue","setProperty","bindingContexts","entitySet","_getMetadataContext","oVisitor","bDoNotResolve","isOpen","oMetadataContext","getAttribute","BindingParser","complexParser","getContext","e","async","processProperties","definitionProperties","aDefinitionPropertiesKeys","propertyValues","sKeyValue","defaultValue","deepClone","error","visitAttribute","attributes","getNamedItem","value","Number","processContexts","contextPath","mMissingContext","oDefinitionContexts","aDefinitionContextsKeys","contextPathIndex","indexOf","contextPathDefinition","splice","propertyValue","length","name","addSingleContext","parseAggregation","oAggregation","processAggregations","oOutObjects","children","childIdx","childDefinition","childKey","setAttribute","aggregationObject","key","position","placement","Placement","After","anchor","tagName","nodeName","processObject","element","myArray","myObject","childNodeNames","map","localName","childIsArray","Set","size","push","processChildren","oAggregations","firstElementChild","oFirstElementChild","namespaceURI","oParent","parentNode","iChildIndex","Array","from","visitNode","nextElementSibling","sChildName","sAggregationName","toUpperCase","defaultAggregation","aggregationDefinition","parsedAggregation","parsedAggregationKey","oNextChild","nextChild","hasVirtualNode","childWrapper","document","createElementNS","appendChild","removeAttribute","oNewChild","cloneNode","aggregationPropertyValues","myChild","processSlots","oMetadataAggregations","processCustomData","arguments","oAggregationElement","oElementChild","sSlotName","oTargetElement","querySelector","prepareAggregationElement","replaceWith","replace","processBuildingBlock","BuildingBlockClass","metadata","sFragmentName","fragment","namespace","publicNamespace","xmlTag","getSettings","JSONModel","initialKeys","oControlConfig","viewData","processedPropertyValues","propName","oData","originalDefinition","validate","isA","getModel","oInstance","getProperties","sContextName","targetObject","isContext","attributeValue","storeObjectValue","newContext","createBindingContext","oAttributesModel","AttributeModel","oPreviousMacroInfo","coreRequire","TraceInfo","isTraceInfoActive","oTraceInfo","traceMacroCalls","macroInfo","oContextVisitor","with","oPromise","insertFragment","oldKeys","temporaryObjectStore","templateString","getRuntimeBuildingBlockTemplate","jsx","renderAsXML","getTemplate","isRuntime","storeKey","hasError","hasParseError","parsedTemplate","parseXMLString","iter","createNodeIterator","NodeFilter","SHOW_TEXT","textnode","nextNode","textContent","trim","processXmlInTrace","initialTemplate","oErrorText","createErrorXML","template","outerHTML","join","visitedNodes","internalNode","Promise","all","remove","resolve","oMacroElement","oRemainingSlots","querySelectorAll","oSlotElement","requireOnMacro","getAttributeNS","substring","setAttributeNS","classList","add","traceDetails","initialProperties","resolvedProperties","missingContexts","oError","stack","oTemplate","oCtx","mSetting","ex","registerBuildingBlock","XMLPreprocessor","plugIn","unregisterBuildingBlock","errorMessages","xmlFragment","additionalData","errorLabels","errorMessage","xml","escapeXMLAttributeValue","errorStack","stackFormatted","btoa","additionalText","JSON","stringify","replaceAll","propertyUID","uid","processNextXmlInTrace","method","returnValue","xmlString","addDefaultNamespaces","xmlDocument","parseFromString","output","parentElement","renderInTraceMode","outStr","xmlResult","innerText","innerHTML","split","strings","i","_len","values","_key","isArray","flat","isFunctionArray","valuefn","isBindingToolkitExpression","compiledExpression","compileExpression","propertyUId","addConditionallyToXML","condition","partToAdd","addAttributeToXML","isUndefinedExpression"],"sources":["./BuildingBlockTemplateProcessor.ts"],"sourcesContent":["import Log from \"sap/base/Log\";\nimport deepClone from \"sap/base/util/deepClone\";\nimport uid from \"sap/base/util/uid\";\nimport type { BindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport { compileExpression, isBindingToolkitExpression, isUndefinedExpression } from \"sap/fe/base/BindingToolkit\";\nimport jsx from \"sap/fe/base/jsx-runtime/jsx\";\nimport type AppComponent from \"sap/fe/core/AppComponent\";\nimport type ResourceModel from \"sap/fe/core/ResourceModel\";\nimport AttributeModel from \"sap/fe/core/buildingBlocks/templating/AttributeModel\";\nimport type {\n\tBuildingBlockAggregationDefinition,\n\tBuildingBlockMetadata,\n\tBuildingBlockMetadataContextDefinition,\n\tBuildingBlockPropertyDefinition,\n\tObjectValue,\n\tObjectValue2\n} from \"sap/fe/core/buildingBlocks/templating/BuildingBlockSupport\";\nimport type BuildingBlockTemplatingBase from \"sap/fe/core/buildingBlocks/templating/BuildingBlockTemplatingBase\";\nimport type RuntimeBuildingBlock from \"sap/fe/core/buildingBlocks/templating/RuntimeBuildingBlock\";\nimport type { Position } from \"sap/fe/core/converters/helpers/ConfigurableObject\";\nimport { Placement } from \"sap/fe/core/converters/helpers/ConfigurableObject\";\nimport type { DefinitionContext, DefinitionPage } from \"sap/fe/core/definition/FEDefinition\";\nimport { isContext, isFunctionArray } from \"sap/fe/core/helpers/TypeGuards\";\nimport BindingParser from \"sap/ui/base/BindingParser\";\nimport type Control from \"sap/ui/core/Control\";\nimport XMLPreprocessor from \"sap/ui/core/util/XMLPreprocessor\";\nimport type Context from \"sap/ui/model/Context\";\nimport type Model from \"sap/ui/model/Model\";\nimport JSONModel from \"sap/ui/model/json/JSONModel\";\nimport type ODataMetaModel from \"sap/ui/model/odata/v4/ODataMetaModel\";\nimport type { MacroInfo } from \"../TraceInfo\";\nimport TraceInfo from \"../TraceInfo\";\n\nconst LOGGER_SCOPE = \"sap.fe.core.buildingBlocks.templating.BuildingBlockTemplateProcessor\";\nconst XMLTEMPLATING_NS = \"http://schemas.sap.com/sapui5/extension/sap.ui.core.template/1\";\nconst DOMParserInstance = new DOMParser();\n\nexport type TransformedBuildingBlockMetadata = BuildingBlockMetadata & {\n\tmetadataContexts: Record<string, BuildingBlockMetadataContextDefinition>;\n};\n\n/**\n * Definition of a meta data context\n */\ntype MetaDataContext = {\n\tname?: string;\n\tmodel: string;\n\tpath: string;\n};\n\nexport type TemplateProcessorSettings = {\n\tcurrentContextPath: Context;\n\tisPublic: boolean;\n\tappComponent: AppComponent;\n\tisRuntimeInstantiation?: boolean;\n\tmodels: Record<string, Model> & {\n\t\tconverterContext: JSONModel;\n\t\tviewData: JSONModel;\n\t\tmetaModel: ODataMetaModel;\n\t\t\"sap.fe.i18n\"?: ResourceModel;\n\t};\n\tgetDefinitionContext(): DefinitionContext;\n\tgetDefinitionForPage(): DefinitionPage;\n\tbindingContexts: Record<string, Context>;\n\t_macroInfo?: MacroInfo;\n\t[k: string]: unknown;\n};\n\nexport type IVisitorCallback = {\n\tgetSettings(): TemplateProcessorSettings;\n\t/**\n\t * Visits the given node and either processes a template instruction, calls\n\t * a visitor, or simply calls both {@link\n\t * sap.ui.core.util.XMLPreprocessor.ICallback.visitAttributes visitAttributes}\n\t * and {@link sap.ui.core.util.XMLPreprocessor.ICallback.visitChildNodes\n\t * visitChildNodes}.\n\t * @param oNode\n\t *   The XML DOM node\n\t * @returns\n\t *   A thenable which resolves with <code>undefined</code> as soon as visiting\n\t *   is done, or is rejected with a corresponding error if visiting fails\n\t */\n\tvisitNode(oNode: Node): Promise<void>;\n\n\t/**\n\t * Inserts the fragment with the given name in place of the given element. Loads the\n\t * fragment, takes care of caching (for the current pre-processor run) and visits the\n\t * fragment's content once it has been imported into the element's owner document and\n\t * put into place. Loading of fragments is asynchronous if the template view is\n\t * asynchronous.\n\t * @param sFragment\n\t *   the fragment's resolved name\n\t * @param oElement\n\t *   the XML DOM element, e.g. <sap.ui.core:Fragment> or <core:ExtensionPoint>\n\t * @param oWith\n\t *   the parent's \"with\" control\n\t * @returns\n\t * A sync promise which resolves with <code>undefined</code> as soon as the fragment\n\t *   has been inserted, or is rejected with a corresponding error if loading or visiting\n\t *   fails.\n\t */\n\tinsertFragment(sFragment: string, oElement: Element, oWith?: Control): Promise<void>;\n\tvisitAttribute(oNode: Element, oAttribute: Attr): Promise<void>;\n\tvisitAttributes(oNode: Element): Promise<void>;\n\tgetViewInfo(): Promise<unknown>;\n\tvisitChildNodes(oNode: Node): Promise<void>;\n\t/**\n\t * Interprets the given XML DOM attribute value as a binding and returns the\n\t * resulting value.\n\t * @param sValue\n\t *   An XML DOM attribute value\n\t * @param [element]\n\t *   The XML DOM element the attribute value belongs to (needed only for\n\t *   warnings which are logged to the console)\n\t * @returns\n\t *   A thenable which resolves with the resulting value, or is rejected with a\n\t *   corresponding error (for example, an error thrown by a formatter) or\n\t *   <code>null</code> in case the binding is not ready (because it refers to a\n\t *   model which is not available) (since 1.57.0)\n\t */\n\tgetResult(sValue: string, element?: Element): Promise<Context> | null;\n\tgetContext(sPath?: string): Context | undefined;\n\t/**\n\t * Returns a callback interface instance for the given map of variables which\n\t * override currently known variables of the same name in <code>this</code>\n\t * parent interface or replace them altogether. Each variable name becomes a\n\t * named model with a corresponding object binding and can be used inside the\n\t * XML template in the usual way, that is, with a binding expression like\n\t * <code>\"{var>some/relative/path}\"</code> (see example).\n\t * @param [mVariables={}]\n\t *   Map from variable name (string) to value\n\t * @param [bReplace]\n\t *   Whether only the given variables are known in the new callback interface\n\t *   instance, no inherited ones\n\t * @returns\n\t *   A callback interface instance\n\t * @param mVariables\n\t * @param bReplace\n\t */\n\t\"with\"(mVariables?: Record<string, Context>, bReplace?: boolean): IVisitorCallback;\n};\n\nfunction validateMacroMetadataContext(\n\tsName: string,\n\tmContexts: Record<string, Context>,\n\toContextSettings: BuildingBlockMetadataContextDefinition,\n\tsKey: string\n): void {\n\tconst oContext = mContexts[sKey];\n\tconst oContextObject = oContext?.getObject() as {\n\t\t$Type?: string;\n\t\t$kind?: string;\n\t};\n\n\tif (oContextSettings.required === true && (!oContext || oContextObject === null)) {\n\t\tthrow new Error(`${sName}: Required metadataContext '${sKey}' is missing`);\n\t} else if (oContextObject) {\n\t\t// If context object has $kind property, $Type should not be checked\n\t\t// Therefore remove from context settings\n\t\tif (oContextObject.hasOwnProperty(\"$kind\") && oContextObject.$kind !== undefined && oContextSettings.expectedTypes !== undefined) {\n\t\t\t// Check if the $kind is part of the allowed ones\n\t\t\tif (!oContextSettings.expectedTypes.includes(oContextObject.$kind)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`${sName}: '${sKey}' must be '$kind' '${oContextSettings.expectedTypes}' but is '${\n\t\t\t\t\t\toContextObject.$kind\n\t\t\t\t\t}': ${oContext.getPath()}`\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (\n\t\t\toContextObject.hasOwnProperty(\"$Type\") &&\n\t\t\toContextObject.$Type !== undefined &&\n\t\t\toContextSettings.expectedAnnotationTypes\n\t\t) {\n\t\t\t// Check only $Type\n\t\t\tif (!oContextSettings.expectedAnnotationTypes.includes(oContextObject.$Type)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`${sName}: '${sKey}' must be '$Type' '${oContextSettings.expectedAnnotationTypes}' but is '${\n\t\t\t\t\t\toContextObject.$Type\n\t\t\t\t\t}': ${oContext.getPath()}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\nexport function validateMacroSignature(\n\tsName: string,\n\toMetadata: TransformedBuildingBlockMetadata,\n\tmContexts: Record<string, Context>,\n\toNode: Element\n): void {\n\tconst aMetadataContextKeys = (oMetadata.metadataContexts && Object.keys(oMetadata.metadataContexts)) || [],\n\t\taProperties = (oMetadata.properties && Object.keys(oMetadata.properties)) || [],\n\t\toAttributeNames: Record<string, boolean> = {};\n\n\t// collect all attributes to find unchecked properties\n\tconst attributeNames = oNode.getAttributeNames();\n\tfor (const attributeName of attributeNames) {\n\t\toAttributeNames[attributeName] = true;\n\t}\n\n\t//Check metadataContexts\n\taMetadataContextKeys.forEach(function (sKey) {\n\t\tconst oContextSettings = oMetadata.metadataContexts[sKey];\n\n\t\tvalidateMacroMetadataContext(sName, mContexts, oContextSettings, sKey);\n\t\tdelete oAttributeNames[sKey];\n\t});\n\t//Check properties\n\taProperties.forEach(function (sKey) {\n\t\tconst oPropertySettings = oMetadata.properties[sKey];\n\t\tif (!oNode.hasAttribute(sKey)) {\n\t\t\tif (oPropertySettings.required && !oPropertySettings.hasOwnProperty(\"defaultValue\")) {\n\t\t\t\tthrow new Error(`${sName}: ` + `Required property '${sKey}' is missing`);\n\t\t\t}\n\t\t} else {\n\t\t\tdelete oAttributeNames[sKey];\n\t\t}\n\t});\n\n\t// Unchecked properties\n\tObject.keys(oAttributeNames).forEach(function (sKey: string) {\n\t\t// no check for properties which contain a colon \":\" (different namespace), e.g. xmlns:trace, trace:macroID, unittest:id\n\t\tif (!sKey.includes(\":\") && !sKey.startsWith(\"xmlns\")) {\n\t\t\tLog.warning(`Unchecked parameter: ${sName}: ${sKey}`, undefined, LOGGER_SCOPE);\n\t\t}\n\t});\n}\n\nconst SAP_UI_CORE_ELEMENT = \"sap.ui.core.Element\";\n\nexport const SAP_UI_MODEL_CONTEXT = \"sap.ui.model.Context\";\n\n/**\n * Transforms the metadata of a building block by adding additional aggregations,\n * and splitting properties into actual properties and metadata contexts.\n * @param buildingBlockMetadata The metadata received from the input\n * @returns The transformed metadata\n */\nfunction transformMetadata(buildingBlockMetadata: BuildingBlockMetadata): TransformedBuildingBlockMetadata {\n\tconst properties: Record<string, BuildingBlockPropertyDefinition> = {\n\t\tclass: {\n\t\t\ttype: \"string\",\n\t\t\tisPublic: true\n\t\t}\n\t};\n\tconst aggregations: Record<string, BuildingBlockAggregationDefinition> = {\n\t\tdependents: {\n\t\t\ttype: SAP_UI_CORE_ELEMENT,\n\t\t\tslot: \"dependents\",\n\t\t\tisPublic: true\n\t\t},\n\t\tcustomData: {\n\t\t\ttype: SAP_UI_CORE_ELEMENT,\n\t\t\tslot: \"customData\",\n\t\t\tisPublic: true\n\t\t},\n\t\tlayoutData: {\n\t\t\ttype: SAP_UI_CORE_ELEMENT,\n\t\t\tslot: \"layoutData\",\n\t\t\tisPublic: true\n\t\t},\n\t\t...buildingBlockMetadata.aggregations\n\t};\n\tconst metadataContexts: Record<string, BuildingBlockMetadataContextDefinition> = {};\n\n\tfor (const propertyName of Object.keys(buildingBlockMetadata.properties)) {\n\t\tconst propertyType = buildingBlockMetadata.properties[propertyName].type;\n\n\t\tif (propertyType !== SAP_UI_MODEL_CONTEXT) {\n\t\t\tproperties[propertyName] = buildingBlockMetadata.properties[propertyName];\n\t\t}\n\n\t\tif ([SAP_UI_MODEL_CONTEXT, \"object\", \"array\"].includes(propertyType)) {\n\t\t\t// Explicitly defined contexts, objects, and arrays may come from the metadataContext\n\t\t\tmetadataContexts[propertyName] = buildingBlockMetadata.properties[propertyName] as BuildingBlockMetadataContextDefinition;\n\t\t}\n\t}\n\n\treturn {\n\t\t...buildingBlockMetadata,\n\t\tproperties,\n\t\tmetadataContexts,\n\t\taggregations\n\t};\n}\n\n/**\n * Checks the absolute or context paths and returns an appropriate MetaContext.\n * @param oSettings Additional settings\n * @param sAttributeValue The attribute value\n * @returns The meta data context object\n */\nfunction _checkAbsoluteAndContextPaths(oSettings: TemplateProcessorSettings, sAttributeValue: string): MetaDataContext {\n\tlet sMetaPath: string;\n\tif (sAttributeValue && sAttributeValue.startsWith(\"/\")) {\n\t\t// absolute path - we just use this one\n\t\tsMetaPath = sAttributeValue;\n\t} else {\n\t\tlet sContextPath = oSettings.currentContextPath.getPath();\n\t\tif (!sContextPath.endsWith(\"/\")) {\n\t\t\tsContextPath += \"/\";\n\t\t}\n\t\tsMetaPath = sContextPath + sAttributeValue;\n\t}\n\treturn {\n\t\tmodel: \"metaModel\",\n\t\tpath: sMetaPath\n\t};\n}\n\n/**\n * This method helps to create the metadata context in case it is not yet available in the store.\n * @param oSettings Additional settings\n * @param sAttributeName The attribute name\n * @param sAttributeValue The attribute value\n * @returns The meta data context object\n */\nfunction _createInitialMetadataContext(\n\toSettings: TemplateProcessorSettings,\n\tsAttributeName: string,\n\tsAttributeValue: string\n): MetaDataContext {\n\tlet returnContext: MetaDataContext;\n\tif (sAttributeValue.startsWith(\"/uid--\") && !oSettings.models.converterContext.getProperty(sAttributeValue)) {\n\t\tconst data = unstoreObjectValue(sAttributeValue);\n\t\toSettings.models.converterContext.setProperty(sAttributeValue, data);\n\t\treturnContext = {\n\t\t\tmodel: \"converterContext\",\n\t\t\tpath: sAttributeValue\n\t\t};\n\t} else if ((sAttributeName === \"metaPath\" && oSettings.currentContextPath) || sAttributeName === \"contextPath\") {\n\t\treturnContext = _checkAbsoluteAndContextPaths(oSettings, sAttributeValue);\n\t} else if (sAttributeValue && sAttributeValue.startsWith(\"/\")) {\n\t\t// absolute path - we just use this one\n\t\treturnContext = {\n\t\t\tmodel: \"metaModel\",\n\t\t\tpath: sAttributeValue\n\t\t};\n\t} else {\n\t\treturnContext = {\n\t\t\tmodel: \"metaModel\",\n\t\t\tpath: oSettings.bindingContexts.entitySet ? oSettings.bindingContexts.entitySet.getPath(sAttributeValue) : sAttributeValue\n\t\t};\n\t}\n\treturn returnContext;\n}\n\nfunction _getMetadataContext(\n\toSettings: TemplateProcessorSettings,\n\toNode: Element,\n\tsAttributeName: string,\n\toVisitor: IVisitorCallback,\n\tbDoNotResolve: boolean,\n\tisOpen: boolean\n): MetaDataContext | undefined {\n\tlet oMetadataContext: MetaDataContext | undefined;\n\tif (!bDoNotResolve && oNode.hasAttribute(sAttributeName)) {\n\t\tconst sAttributeValue = oNode.getAttribute(sAttributeName) as string;\n\t\toMetadataContext = BindingParser.complexParser(sAttributeValue);\n\t\tif (!oMetadataContext) {\n\t\t\toMetadataContext = _createInitialMetadataContext(oSettings, sAttributeName, sAttributeValue);\n\t\t}\n\t} else if (oSettings.bindingContexts.hasOwnProperty(sAttributeName)) {\n\t\toMetadataContext = {\n\t\t\tmodel: sAttributeName,\n\t\t\tpath: \"\"\n\t\t};\n\t} else if (isOpen) {\n\t\ttry {\n\t\t\tif (oVisitor.getContext(`${sAttributeName}>`)) {\n\t\t\t\toMetadataContext = {\n\t\t\t\t\tmodel: sAttributeName,\n\t\t\t\t\tpath: \"\"\n\t\t\t\t};\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\treturn oMetadataContext;\n}\n\n/**\n * Parse the incoming XML node and try to resolve the properties defined there.\n * @param oMetadata The metadata for the building block\n * @param oNode The XML node to parse\n * @param isPublic Whether the building block is used in a public context or not\n * @param oVisitor The visitor instance\n * @returns The processed properties\n */\nasync function processProperties(\n\toMetadata: TransformedBuildingBlockMetadata,\n\toNode: Element,\n\tisPublic: boolean,\n\toVisitor: IVisitorCallback\n): Promise<Record<string, ObjectValue>> {\n\tconst definitionProperties = oMetadata.properties;\n\n\t// Retrieve properties values\n\tconst aDefinitionPropertiesKeys = Object.keys(definitionProperties);\n\n\tconst propertyValues: Record<string, ObjectValue> = {};\n\tfor (const sKeyValue of aDefinitionPropertiesKeys) {\n\t\tif (definitionProperties[sKeyValue].type === \"object\") {\n\t\t\tpropertyValues[sKeyValue] =\n\t\t\t\tdefinitionProperties[sKeyValue].defaultValue && deepClone(definitionProperties[sKeyValue].defaultValue); // To avoid values being reused across macros\n\t\t} else {\n\t\t\tpropertyValues[sKeyValue] = definitionProperties[sKeyValue].defaultValue as string | boolean | number;\n\t\t}\n\n\t\tif (oNode.hasAttribute(sKeyValue) && isPublic && definitionProperties[sKeyValue].isPublic !== true) {\n\t\t\tLog.error(`Property ${sKeyValue} was ignored as it is not intended for public usage`);\n\t\t} else if (oNode.hasAttribute(sKeyValue)) {\n\t\t\tawait oVisitor.visitAttribute(oNode, oNode.attributes.getNamedItem(sKeyValue) as Attr);\n\t\t\tlet value: string | boolean | number | null | undefined = oNode.getAttribute(sKeyValue);\n\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\tif (typeof value === \"string\" && !value.startsWith(\"{\")) {\n\t\t\t\t\tswitch (definitionProperties[sKeyValue].type) {\n\t\t\t\t\t\tcase \"boolean\":\n\t\t\t\t\t\t\tvalue = value === \"true\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"number\":\n\t\t\t\t\t\t\tvalue = Number(value);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvalue = value === null ? undefined : value;\n\t\t\t\tpropertyValues[sKeyValue] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn propertyValues;\n}\n\n/**\n * Parse the incoming XML node and try to resolve the binding contexts defined inside.\n * @param oMetadata The metadata for the building block\n * @param oSettings The settings object\n * @param oNode The XML node to parse\n * @param isPublic Whether the building block is used in a public context or not\n * @param oVisitor The visitor instance\n * @param mContexts The contexts to be used\n * @param propertyValues The current property values\n * @returns The processed and missing contexts\n */\nfunction processContexts(\n\toMetadata: TransformedBuildingBlockMetadata,\n\toSettings: TemplateProcessorSettings,\n\toNode: Element,\n\tisPublic: boolean,\n\toVisitor: IVisitorCallback,\n\tmContexts: Record<string, Context>,\n\tpropertyValues: Record<string, ObjectValue>\n): Record<string, boolean> {\n\toSettings.currentContextPath = oSettings.bindingContexts.contextPath;\n\tconst mMissingContext: Record<string, boolean> = {};\n\tconst oDefinitionContexts = oMetadata.metadataContexts;\n\tconst aDefinitionContextsKeys = Object.keys(oDefinitionContexts);\n\t// Since the metaPath and other property can be relative to the contextPath we need to evaluate the current contextPath first\n\tconst contextPathIndex = aDefinitionContextsKeys.indexOf(\"contextPath\");\n\tif (contextPathIndex !== -1) {\n\t\t// If it is defined we extract it and reinsert it in the first position of the array\n\t\tconst contextPathDefinition = aDefinitionContextsKeys.splice(contextPathIndex, 1);\n\t\taDefinitionContextsKeys.splice(0, 0, contextPathDefinition[0]);\n\t}\n\tfor (const sAttributeName of aDefinitionContextsKeys) {\n\t\t// If the context was resolved as a property (binding / xml aggregation) then we don't need to resolve it here.\n\t\tconst propertyValue = propertyValues[sAttributeName];\n\t\tif (propertyValue !== undefined && typeof propertyValue === \"object\" && Object.keys(propertyValue as object).length > 0) {\n\t\t\tdelete oMetadata.metadataContexts[sAttributeName];\n\t\t\tcontinue;\n\t\t}\n\t\tconst bDoNotResolve = isPublic && oDefinitionContexts[sAttributeName].isPublic === false && oNode.hasAttribute(sAttributeName);\n\t\tconst oMetadataContext = _getMetadataContext(oSettings, oNode, sAttributeName, oVisitor, bDoNotResolve, oMetadata.isOpen ?? false);\n\t\tif (oMetadataContext) {\n\t\t\toMetadataContext.name = sAttributeName;\n\t\t\taddSingleContext(mContexts, oVisitor, oMetadataContext);\n\t\t\tif (\n\t\t\t\t(sAttributeName === \"entitySet\" || sAttributeName === \"contextPath\") &&\n\t\t\t\t!oSettings.bindingContexts.hasOwnProperty(sAttributeName)\n\t\t\t) {\n\t\t\t\toSettings.bindingContexts[sAttributeName] = mContexts[sAttributeName];\n\t\t\t}\n\t\t\tif (sAttributeName === \"contextPath\") {\n\t\t\t\toSettings.currentContextPath = mContexts[sAttributeName];\n\t\t\t}\n\t\t\tif (mContexts[sAttributeName] !== undefined) {\n\t\t\t\tpropertyValues[sAttributeName] = mContexts[sAttributeName];\n\t\t\t} else if (typeof propertyValues[sAttributeName] === \"string\") {\n\t\t\t\t// If the binding couldn't be resolved consider that there was no value here\n\t\t\t\tdelete oMetadata.metadataContexts[sAttributeName];\n\t\t\t}\n\t\t} else {\n\t\t\tmMissingContext[sAttributeName] = true;\n\t\t}\n\t}\n\treturn mMissingContext;\n}\n\nexport type BuildingBlockAggregation = {\n\tkey: string;\n\tposition: Position;\n\ttype: \"Slot\";\n};\nfunction parseAggregation(oAggregation?: Element, processAggregations?: Function): Record<string, BuildingBlockAggregation> {\n\tconst oOutObjects: Record<string, BuildingBlockAggregation> = {};\n\tif (oAggregation && oAggregation.children.length > 0) {\n\t\tconst children = oAggregation.children;\n\t\tfor (let childIdx = 0; childIdx < children.length; childIdx++) {\n\t\t\tconst childDefinition = children[childIdx];\n\t\t\tlet childKey = childDefinition.getAttribute(\"key\") || childDefinition.getAttribute(\"id\");\n\t\t\tif (childKey) {\n\t\t\t\tchildKey = `InlineXML_${childKey}`;\n\t\t\t\tchildDefinition.setAttribute(\"key\", childKey);\n\t\t\t\tlet aggregationObject: BuildingBlockAggregation = {\n\t\t\t\t\tkey: childKey,\n\t\t\t\t\tposition: {\n\t\t\t\t\t\tplacement: (childDefinition.getAttribute(\"placement\") as Placement) || Placement.After,\n\t\t\t\t\t\tanchor: childDefinition.getAttribute(\"anchor\") || undefined\n\t\t\t\t\t},\n\t\t\t\t\ttype: \"Slot\"\n\t\t\t\t};\n\t\t\t\tif (processAggregations) {\n\t\t\t\t\taggregationObject = processAggregations(childDefinition, aggregationObject);\n\t\t\t\t}\n\t\t\t\toOutObjects[aggregationObject.key] = aggregationObject;\n\t\t\t} else if (childDefinition.tagName !== \"slot\") {\n\t\t\t\tLog.error(`The aggregation ${childDefinition.nodeName} is missing a Key attribute. It is not displayed`);\n\t\t\t}\n\t\t}\n\t}\n\treturn oOutObjects;\n}\n\n/**\n * Processes the child nodes of the building block properties when the type is an object.\n * @param element The XML element to parse\n * @returns The processed object\n */\nfunction processObject(element: Element): object {\n\tconst children = element.children;\n\tconst myArray: Array<unknown> = [];\n\tconst myObject: Record<string, unknown> = {};\n\tfor (const attributeName of element.getAttributeNames()) {\n\t\tmyObject[attributeName] = element.getAttribute(attributeName);\n\t}\n\tif (children.length > 0) {\n\t\tconst childNodeNames = Object.keys(children).map((key) => children[key as unknown as number].localName);\n\t\tconst childIsArray = childNodeNames.length !== new Set(childNodeNames).size;\n\t\tfor (const childDefinition of children as unknown as Array<Element>) {\n\t\t\tif (childIsArray) {\n\t\t\t\tmyArray.push(processObject(childDefinition));\n\t\t\t} else {\n\t\t\t\tmyObject[childDefinition.localName] = processObject(childDefinition);\n\t\t\t}\n\t\t}\n\t\tif (childIsArray) {\n\t\t\treturn myArray;\n\t\t}\n\t}\n\treturn myObject;\n}\n\n/**\n * Processes the child nodes of the building block and parses them as either aggregations or object-/array-based values.\n * @param oNode The XML node for which to process the children\n * @param oVisitor The visitor instance\n * @param oMetadata The metadata for the building block\n * @param isPublic Whether the building block is used in a public context or not\n * @param propertyValues The values of already parsed property\n * @returns The processed children\n */\nasync function processChildren(\n\toNode: Element,\n\toVisitor: IVisitorCallback,\n\toMetadata: TransformedBuildingBlockMetadata,\n\tisPublic: boolean,\n\tpropertyValues: Record<string, ObjectValue>\n): Promise<Record<string, Element>> {\n\tconst oAggregations: Record<string, Element> = {};\n\tif (oNode.firstElementChild !== null) {\n\t\tlet oFirstElementChild: Element | null = oNode.firstElementChild as Element | null;\n\n\t\twhile (oFirstElementChild !== null) {\n\t\t\tif (oFirstElementChild.namespaceURI === XMLTEMPLATING_NS) {\n\t\t\t\t// In case we encounter a templating tag, run the visitor on it and continue with the resulting child\n\t\t\t\tconst oParent = oFirstElementChild.parentNode;\n\t\t\t\tif (oParent) {\n\t\t\t\t\tconst iChildIndex = Array.from(oParent.children).indexOf(oFirstElementChild);\n\t\t\t\t\tawait oVisitor.visitNode(oFirstElementChild);\n\t\t\t\t\toFirstElementChild = oParent.children[iChildIndex] ? oParent.children[iChildIndex] : null;\n\t\t\t\t} else {\n\t\t\t\t\t// Not sure how this could happen but I also don't want to create infinite loops\n\t\t\t\t\toFirstElementChild = oFirstElementChild.nextElementSibling;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst sChildName = oFirstElementChild.localName;\n\t\t\t\tlet sAggregationName = sChildName;\n\t\t\t\tif (sAggregationName[0].toUpperCase() === sAggregationName[0]) {\n\t\t\t\t\t// not a sub aggregation, go back to default Aggregation\n\t\t\t\t\tsAggregationName = oMetadata.defaultAggregation || \"\";\n\t\t\t\t}\n\t\t\t\tconst aggregationDefinition = oMetadata.aggregations[sAggregationName];\n\t\t\t\tif (aggregationDefinition !== undefined && !aggregationDefinition.slot) {\n\t\t\t\t\tconst parsedAggregation = parseAggregation(oFirstElementChild, aggregationDefinition.processAggregations);\n\t\t\t\t\tpropertyValues[sAggregationName] = parsedAggregation;\n\t\t\t\t\tfor (const parsedAggregationKey in parsedAggregation) {\n\t\t\t\t\t\toMetadata.aggregations[parsedAggregationKey] = parsedAggregation[parsedAggregationKey];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toFirstElementChild = oFirstElementChild.nextElementSibling;\n\t\t\t}\n\t\t}\n\n\t\toFirstElementChild = oNode.firstElementChild;\n\t\twhile (oFirstElementChild !== null) {\n\t\t\tconst oNextChild: Element | null = oFirstElementChild.nextElementSibling;\n\t\t\tconst sChildName = oFirstElementChild.localName;\n\t\t\tlet sAggregationName = sChildName;\n\t\t\tif (sAggregationName[0].toUpperCase() === sAggregationName[0]) {\n\t\t\t\t// not a sub aggregation, go back to default Aggregation\n\t\t\t\tsAggregationName = oMetadata.defaultAggregation || \"\";\n\t\t\t}\n\t\t\tif (\n\t\t\t\tObject.keys(oMetadata.aggregations).includes(sAggregationName) &&\n\t\t\t\t(!isPublic || oMetadata.aggregations[sAggregationName].isPublic === true)\n\t\t\t) {\n\t\t\t\tconst aggregationDefinition = oMetadata.aggregations[sAggregationName];\n\t\t\t\tif (!aggregationDefinition.slot && oFirstElementChild !== null && oFirstElementChild.children.length > 0) {\n\t\t\t\t\tawait oVisitor.visitNode(oFirstElementChild);\n\t\t\t\t\tlet childDefinition = oFirstElementChild.firstElementChild;\n\t\t\t\t\twhile (childDefinition) {\n\t\t\t\t\t\tconst nextChild = childDefinition.nextElementSibling;\n\t\t\t\t\t\tif (!aggregationDefinition.hasVirtualNode) {\n\t\t\t\t\t\t\tconst childWrapper = document.createElementNS(oNode.namespaceURI, childDefinition.getAttribute(\"key\")!);\n\t\t\t\t\t\t\tchildWrapper.appendChild(childDefinition);\n\t\t\t\t\t\t\toAggregations[childDefinition.getAttribute(\"key\")!] = childWrapper;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toAggregations[childDefinition.getAttribute(\"key\")!] = childDefinition;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tchildDefinition.removeAttribute(\"key\");\n\t\t\t\t\t\tchildDefinition = nextChild;\n\t\t\t\t\t}\n\t\t\t\t} else if (aggregationDefinition.slot) {\n\t\t\t\t\tawait oVisitor.visitNode(oFirstElementChild);\n\t\t\t\t\tif (sAggregationName !== sChildName) {\n\t\t\t\t\t\tif (!oAggregations[sAggregationName]) {\n\t\t\t\t\t\t\tconst oNewChild = document.createElementNS(oNode.namespaceURI, sAggregationName);\n\t\t\t\t\t\t\toAggregations[sAggregationName] = oNewChild;\n\t\t\t\t\t\t}\n\t\t\t\t\t\toAggregations[sAggregationName].appendChild(oFirstElementChild.cloneNode(true) as Element);\n\t\t\t\t\t} else {\n\t\t\t\t\t\toAggregations[sAggregationName] = oFirstElementChild.cloneNode(true) as Element;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (Object.keys(oMetadata.properties).includes(sAggregationName)) {\n\t\t\t\tawait oVisitor.visitNode(oFirstElementChild);\n\t\t\t\tif (oMetadata.properties[sAggregationName].type === \"object\") {\n\t\t\t\t\tconst aggregationPropertyValues = processObject(oFirstElementChild);\n\t\t\t\t\tpropertyValues[sAggregationName] = aggregationPropertyValues;\n\t\t\t\t} else if (oMetadata.properties[sAggregationName].type === \"array\") {\n\t\t\t\t\tif (oFirstElementChild !== null && oFirstElementChild.children.length > 0) {\n\t\t\t\t\t\tconst children = oFirstElementChild.children;\n\t\t\t\t\t\tconst oOutObjects: Record<string, ObjectValue2>[] = [];\n\t\t\t\t\t\tfor (let childIdx = 0; childIdx < children.length; childIdx++) {\n\t\t\t\t\t\t\tconst childDefinition = children[childIdx];\n\t\t\t\t\t\t\t// non keyed child, just add it to the aggregation\n\t\t\t\t\t\t\tconst myChild: Record<string, ObjectValue2> = {};\n\t\t\t\t\t\t\tconst attributeNames = childDefinition.getAttributeNames();\n\t\t\t\t\t\t\tfor (const attributeName of attributeNames) {\n\t\t\t\t\t\t\t\tmyChild[attributeName] = childDefinition.getAttribute(attributeName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toOutObjects.push(myChild);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpropertyValues[sAggregationName] = oOutObjects;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toFirstElementChild = oNextChild;\n\t\t}\n\t}\n\treturn oAggregations;\n}\n\nfunction processSlots(\n\toAggregations: Record<string, Element>,\n\toMetadataAggregations: Record<string, BuildingBlockAggregationDefinition>,\n\toNode: Element,\n\tprocessCustomData = false\n): void {\n\tif (Object.keys(oAggregations).length > 0) {\n\t\tObject.keys(oAggregations).forEach(function (sAggregationName: string) {\n\t\t\tconst oAggregationElement = oAggregations[sAggregationName];\n\t\t\tif (oNode !== null && oNode !== undefined && oAggregationElement) {\n\t\t\t\t// slots can have :: as keys which is not a valid aggregation name therefore replacing them\n\t\t\t\tconst oElementChild = oAggregationElement.firstElementChild;\n\t\t\t\tif (![\"dependents\", \"customData\", \"layoutData\"].includes(sAggregationName)) {\n\t\t\t\t\tconst sSlotName =\n\t\t\t\t\t\t(oMetadataAggregations[sAggregationName] !== undefined && oMetadataAggregations[sAggregationName].slot) ||\n\t\t\t\t\t\tsAggregationName;\n\t\t\t\t\tconst oTargetElement = oNode.querySelector(`slot[name='${sSlotName}']`);\n\t\t\t\t\tif (oTargetElement !== null) {\n\t\t\t\t\t\tconst oNewChild = prepareAggregationElement(oNode, sAggregationName, oElementChild);\n\t\t\t\t\t\toTargetElement.replaceWith(...(oNewChild.children as unknown as Node[])); // Somehow TS doesn't like this but the documentation says is should work\n\t\t\t\t\t}\n\t\t\t\t} else if (processCustomData && oElementChild !== null) {\n\t\t\t\t\tconst sSlotName =\n\t\t\t\t\t\t(oMetadataAggregations[sAggregationName] !== undefined && oMetadataAggregations[sAggregationName].slot) ||\n\t\t\t\t\t\tsAggregationName;\n\t\t\t\t\tconst oTargetElement = oNode.querySelector(`slot[name='${sSlotName}']`);\n\t\t\t\t\tconst oNewChild = prepareAggregationElement(oNode, sAggregationName, oElementChild);\n\t\t\t\t\tif (oTargetElement !== null) {\n\t\t\t\t\t\toTargetElement.replaceWith(...(oNewChild.children as unknown as Node[])); // Somehow TS doesn't like this but the documentation says is should work\n\t\t\t\t\t} else {\n\t\t\t\t\t\toNode.appendChild(oNewChild);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction prepareAggregationElement(oNode: Element, sAggregationName: string, oElementChild: Element | null): Element {\n\tconst oNewChild = document.createElementNS(oNode.namespaceURI, sAggregationName.replace(/:/gi, \"_\"));\n\twhile (oElementChild) {\n\t\tconst oNextChild = oElementChild.nextElementSibling;\n\t\toNewChild.appendChild(oElementChild);\n\t\toElementChild = oNextChild;\n\t}\n\treturn oNewChild;\n}\n\nasync function processBuildingBlock(\n\tBuildingBlockClass: typeof BuildingBlockTemplatingBase,\n\toNode: Element,\n\toVisitor: IVisitorCallback,\n\tisPublic = false\n): Promise<void> {\n\tconst oMetadata = transformMetadata(BuildingBlockClass.metadata);\n\n\tconst sFragmentName = oMetadata.fragment ?? `${oMetadata.namespace ?? oMetadata.publicNamespace}.${oMetadata.xmlTag ?? oMetadata.name}`;\n\n\tconst mContexts: Record<string, Context> = {};\n\tconst oSettings = oVisitor.getSettings();\n\n\t// Add an empty converter context if there is none in order to have a place to store object values\n\toSettings.models.converterContext ??= new JSONModel();\n\n\t//Inject storage for macros\n\tif (!oSettings[sFragmentName]) {\n\t\toSettings[sFragmentName] = {};\n\t}\n\n\t// First of all we need to visit the attributes to resolve the properties and the metadata contexts\n\tconst propertyValues = await processProperties(oMetadata, oNode, isPublic, oVisitor);\n\tconst initialKeys = Object.keys(propertyValues);\n\tconst mMissingContext = processContexts(oMetadata, oSettings, oNode, isPublic, oVisitor, mContexts, propertyValues);\n\n\ttry {\n\t\t// Aggregation and complex type support\n\t\tconst oAggregations = await processChildren(oNode, oVisitor, oMetadata, isPublic, propertyValues);\n\t\tlet oControlConfig = {};\n\n\t\tif (oSettings.models.viewData) {\n\t\t\t// Only used in the Field macro and even then maybe not really useful\n\t\t\toControlConfig = oSettings.models.viewData.getProperty(\"/controlConfiguration\");\n\t\t}\n\t\tlet processedPropertyValues = propertyValues;\n\n\t\tObject.keys(propertyValues).forEach((propName) => {\n\t\t\tlet oData = propertyValues[propName] as unknown as Context;\n\t\t\t//check for additional processing function to validate / overwrite parameters\n\t\t\tconst originalDefinition = BuildingBlockClass?.metadata?.properties[propName];\n\t\t\tif (originalDefinition?.validate) {\n\t\t\t\toData = originalDefinition.validate(oData) || oData;\n\t\t\t}\n\t\t\tif (oData?.isA?.(SAP_UI_MODEL_CONTEXT) && !oData.getModel().isA(\"sap.ui.model.odata.v4.ODataMetaModel\")) {\n\t\t\t\tpropertyValues[propName] = oData.getObject();\n\t\t\t}\n\t\t});\n\t\tpropertyValues.isPublic = isPublic;\n\n\t\tconst oInstance = new BuildingBlockClass({ ...propertyValues, ...oAggregations }, oControlConfig, oSettings);\n\t\tprocessedPropertyValues = oInstance.getProperties();\n\t\tObject.keys(oMetadata.metadataContexts).forEach(function (sContextName: string) {\n\t\t\tif (processedPropertyValues.hasOwnProperty(sContextName)) {\n\t\t\t\tconst targetObject = processedPropertyValues[sContextName];\n\t\t\t\tif (isContext(targetObject)) {\n\t\t\t\t\tmContexts[sContextName] = targetObject as Context;\n\t\t\t\t} else if (typeof targetObject === \"object\") {\n\t\t\t\t\tconst attributeValue = storeObjectValue(targetObject);\n\t\t\t\t\toSettings.models.converterContext.setProperty(attributeValue, targetObject);\n\t\t\t\t\tconst newContext = oSettings.models.converterContext.createBindingContext(attributeValue)!;\n\t\t\t\t\tunstoreObjectValue(attributeValue);\n\t\t\t\t\tmContexts[sContextName] = newContext;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst oAttributesModel: JSONModel = new AttributeModel(oNode, processedPropertyValues, BuildingBlockClass);\n\t\tmContexts[\"this\"] = oAttributesModel.createBindingContext(\"/\");\n\t\tlet oPreviousMacroInfo: MacroInfo | undefined;\n\t\t// core:require need to be defined on the node itself to be picked up due to the templating step\n\t\tconst coreRequire = oNode?.getAttribute(\"core:require\") || undefined;\n\n\t\t// Keep track\n\t\tif (TraceInfo.isTraceInfoActive()) {\n\t\t\tconst oTraceInfo = TraceInfo.traceMacroCalls(sFragmentName, oMetadata, mContexts, oNode, oVisitor);\n\t\t\tif (oTraceInfo?.macroInfo) {\n\t\t\t\toPreviousMacroInfo = oSettings[\"_macroInfo\"];\n\t\t\t\toSettings[\"_macroInfo\"] = oTraceInfo.macroInfo;\n\t\t\t}\n\t\t}\n\t\tvalidateMacroSignature(sFragmentName, oMetadata, mContexts, oNode);\n\n\t\tconst oContextVisitor = oVisitor.with(mContexts, oMetadata.isOpen !== undefined ? !oMetadata.isOpen : true);\n\t\tconst oParent = oNode.parentNode;\n\n\t\tlet iChildIndex: number;\n\t\tlet oPromise;\n\t\tif (oParent) {\n\t\t\tiChildIndex = Array.from(oParent.children).indexOf(oNode);\n\n\t\t\tif (oMetadata.fragment) {\n\t\t\t\toPromise = oContextVisitor.insertFragment(sFragmentName, oNode);\n\t\t\t} else {\n\t\t\t\tconst oldKeys = Object.keys(temporaryObjectStore);\n\t\t\t\tlet templateString;\n\t\t\t\tif ((oInstance as RuntimeBuildingBlock).getRuntimeBuildingBlockTemplate) {\n\t\t\t\t\ttemplateString = await jsx.renderAsXML(async () =>\n\t\t\t\t\t\t(oInstance as RuntimeBuildingBlock).getRuntimeBuildingBlockTemplate(oNode)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\ttemplateString = await jsx.renderAsXML(async () => oInstance.getTemplate!(oNode));\n\t\t\t\t}\n\n\t\t\t\tif (BuildingBlockClass.isRuntime) {\n\t\t\t\t\t// For runtime building blocks, we need to attach all objects to the converterContext directly, as the actual rendering takes place at runtime\n\t\t\t\t\tfor (const storeKey in temporaryObjectStore) {\n\t\t\t\t\t\tif (!oldKeys.includes(storeKey)) {\n\t\t\t\t\t\t\tconst data = unstoreObjectValue(storeKey);\n\t\t\t\t\t\t\toSettings.models.converterContext.setProperty(storeKey, data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet hasError = \"\";\n\t\t\t\tif (templateString) {\n\t\t\t\t\tlet hasParseError = false;\n\t\t\t\t\tlet parsedTemplate = parseXMLString(templateString, true);\n\t\t\t\t\t// For safety purpose we try to detect trailing text in between XML Tags\n\t\t\t\t\tfor (const element of parsedTemplate) {\n\t\t\t\t\t\tconst iter = document.createNodeIterator(element, NodeFilter.SHOW_TEXT);\n\t\t\t\t\t\tlet textnode = iter.nextNode();\n\t\t\t\t\t\tif (element.localName === \"parsererror\") {\n\t\t\t\t\t\t\thasParseError = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (textnode) {\n\t\t\t\t\t\t\tif (textnode.textContent && textnode.textContent.trim().length > 0) {\n\t\t\t\t\t\t\t\thasError = textnode.textContent;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextnode = iter.nextNode();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hasParseError) {\n\t\t\t\t\t\t// If there is a parseerror while processing the XML it means the XML itself is malformed, as such we rerun the template process\n\t\t\t\t\t\t// Setting isTraceMode true will make it so that each xml` expression is checked for validity from XML perspective\n\t\t\t\t\t\t// If an error is found it's returned instead of the normal fragment\n\t\t\t\t\t\tLog.error(`Error while processing building block ${oMetadata.xmlTag || oMetadata.name}`, hasError);\n\t\t\t\t\t\tparsedTemplate = (await processXmlInTrace(async () => {\n\t\t\t\t\t\t\tlet initialTemplate;\n\t\t\t\t\t\t\tif ((oInstance as RuntimeBuildingBlock).getRuntimeBuildingBlockTemplate) {\n\t\t\t\t\t\t\t\tinitialTemplate = await jsx.renderAsXML(async () =>\n\t\t\t\t\t\t\t\t\t(oInstance as RuntimeBuildingBlock).getRuntimeBuildingBlockTemplate(oNode)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tinitialTemplate = await jsx.renderAsXML(async () => oInstance.getTemplate!(oNode));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn parseXMLString(initialTemplate ?? \"\", true);\n\t\t\t\t\t\t})) as Element[];\n\t\t\t\t\t} else if (hasError.length > 0) {\n\t\t\t\t\t\t// If there is trailing text we create a standard error and display it.\n\t\t\t\t\t\tLog.error(`Error while processing building block ${oMetadata.xmlTag || oMetadata.name}`);\n\t\t\t\t\t\tconst oErrorText = createErrorXML(\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t`Error while processing building block ${oMetadata.xmlTag || oMetadata.name}`,\n\t\t\t\t\t\t\t\t`Trailing text was found in the XML: ${hasError}`\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tparsedTemplate.map((template) => template.outerHTML).join(\"\\n\")\n\t\t\t\t\t\t);\n\t\t\t\t\t\tparsedTemplate = parseXMLString(oErrorText, true);\n\t\t\t\t\t}\n\t\t\t\t\toNode.replaceWith(...parsedTemplate);\n\n\t\t\t\t\tconst visitedNodes = parsedTemplate.map(async (internalNode) => {\n\t\t\t\t\t\tprocessSlots(oAggregations, oMetadata.aggregations, internalNode, false);\n\t\t\t\t\t\treturn oContextVisitor.visitNode(internalNode);\n\t\t\t\t\t});\n\t\t\t\t\toPromise = Promise.all(visitedNodes);\n\t\t\t\t} else {\n\t\t\t\t\toNode.remove();\n\t\t\t\t\toPromise = Promise.resolve();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait oPromise;\n\t\t\tconst oMacroElement = oParent.children[iChildIndex];\n\t\t\tprocessSlots(oAggregations, oMetadata.aggregations, oMacroElement, true);\n\t\t\tif (oMacroElement !== undefined) {\n\t\t\t\tconst oRemainingSlots = oMacroElement.querySelectorAll(\"slot\");\n\t\t\t\toRemainingSlots.forEach(function (oSlotElement) {\n\t\t\t\t\toSlotElement.remove();\n\t\t\t\t});\n\t\t\t\tif (coreRequire) {\n\t\t\t\t\tlet requireOnMacro = oMacroElement.getAttributeNS(\"sap.ui.core\", \"require\");\n\t\t\t\t\tif (requireOnMacro) {\n\t\t\t\t\t\trequireOnMacro = requireOnMacro.substring(0, requireOnMacro.length - 1) + \",\" + coreRequire.substring(1); // Remove last } and first {\n\t\t\t\t\t} else {\n\t\t\t\t\t\trequireOnMacro = coreRequire;\n\t\t\t\t\t}\n\t\t\t\t\toMacroElement.setAttributeNS(\"sap.ui.core\", \"core:require\", requireOnMacro);\n\t\t\t\t}\n\t\t\t\tif (propertyValues.class && !BuildingBlockClass.isRuntime) {\n\t\t\t\t\toMacroElement.classList.add(propertyValues.class as string);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (oPreviousMacroInfo) {\n\t\t\t//restore macro info if available\n\t\t\toSettings[\"_macroInfo\"] = oPreviousMacroInfo;\n\t\t} else {\n\t\t\tdelete oSettings[\"_macroInfo\"];\n\t\t}\n\t} catch (e: unknown) {\n\t\t// In case there is a generic error (usually code error), we retrieve the current context information and create a dedicated error message\n\n\t\tconst traceDetails = {\n\t\t\tinitialProperties: {} as Record<string, unknown>,\n\t\t\tresolvedProperties: {} as Record<string, unknown>,\n\t\t\tmissingContexts: mMissingContext\n\t\t};\n\t\tfor (const propertyName of initialKeys) {\n\t\t\tconst propertyValue = propertyValues[propertyName];\n\t\t\tif (isContext(propertyValue)) {\n\t\t\t\ttraceDetails.initialProperties[propertyName] = {\n\t\t\t\t\tpath: propertyValue.getPath(),\n\t\t\t\t\tvalue: propertyValue.getObject()\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\ttraceDetails.initialProperties[propertyName] = propertyValue;\n\t\t\t}\n\t\t}\n\t\tfor (const propertyName in propertyValues) {\n\t\t\tconst propertyValue = propertyValues[propertyName];\n\t\t\tif (!initialKeys.includes(propertyName)) {\n\t\t\t\tif (isContext(propertyValue)) {\n\t\t\t\t\ttraceDetails.resolvedProperties[propertyName] = {\n\t\t\t\t\t\tpath: propertyValue.getPath(),\n\t\t\t\t\t\tvalue: propertyValue.getObject()\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\ttraceDetails.resolvedProperties[propertyName] = propertyValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLog.error(e as string);\n\t\tconst oError = createErrorXML(\n\t\t\t[`Error while processing building block ${oMetadata.name}`],\n\t\t\toNode.outerHTML,\n\t\t\ttraceDetails,\n\t\t\t(e as Error).stack\n\t\t);\n\t\tconst oTemplate = parseXMLString(oError, true);\n\t\toNode.replaceWith(...oTemplate);\n\t}\n}\nfunction addSingleContext(\n\tmContexts: Record<string, Context | undefined>,\n\toVisitor: IVisitorCallback,\n\toCtx: {\n\t\tname?: string;\n\t\tpath: string;\n\t\tmodel?: string;\n\t}\n): void {\n\tconst sKey = (oCtx.name || oCtx.model || undefined) as string;\n\tif (mContexts[sKey]) {\n\t\treturn; // do not add twice\n\t}\n\ttry {\n\t\tlet sContextPath = oCtx.path;\n\t\tif (oCtx.model !== null) {\n\t\t\tsContextPath = `${oCtx.model}>${sContextPath}`;\n\t\t}\n\t\tconst mSetting = oVisitor.getSettings();\n\t\tif (oCtx.model === \"converterContext\" && oCtx.path.length > 0) {\n\t\t\tmContexts[sKey] = mSetting.models[oCtx.model].getContext(oCtx.path /*, mSetting.bindingContexts[oCtx.model]*/); // add the context to the visitor\n\t\t} else if (!mSetting.bindingContexts[oCtx.model!] && mSetting.models[oCtx.model!]) {\n\t\t\tmContexts[sKey] = mSetting.models[oCtx.model!].getContext(oCtx.path); // add the context to the visitor\n\t\t} else {\n\t\t\tmContexts[sKey] = oVisitor.getContext(sContextPath); // add the context to the visitor\n\t\t}\n\t} catch (ex) {\n\t\t// ignore the context as this can only be the case if the model is not ready,\n\t\t// i.e. not a preprocessing model but maybe a model for providing afterwards\n\t}\n}\n\n/**\n * Register a building block definition to be used inside the xml template processor.\n * @param BuildingBlockClass The building block definition\n */\nexport function registerBuildingBlock(BuildingBlockClass: typeof BuildingBlockTemplatingBase): void {\n\tif (BuildingBlockClass.metadata.namespace !== undefined) {\n\t\tXMLPreprocessor.plugIn(\n\t\t\tasync (oNode: Element, oVisitor: IVisitorCallback) => processBuildingBlock(BuildingBlockClass, oNode, oVisitor),\n\t\t\tBuildingBlockClass.metadata.namespace,\n\t\t\tBuildingBlockClass.metadata.xmlTag || BuildingBlockClass.metadata.name\n\t\t);\n\t}\n\tif (BuildingBlockClass.metadata.publicNamespace !== undefined) {\n\t\tXMLPreprocessor.plugIn(\n\t\t\tasync (oNode: Element, oVisitor: IVisitorCallback) => processBuildingBlock(BuildingBlockClass, oNode, oVisitor, true),\n\t\t\tBuildingBlockClass.metadata.publicNamespace,\n\t\t\tBuildingBlockClass.metadata.xmlTag || BuildingBlockClass.metadata.name\n\t\t);\n\t}\n}\n\n/**\n * UnRegister a building block definition so that it is no longer used inside the xml template processor.\n * @param BuildingBlockClass The building block definition\n */\nexport function unregisterBuildingBlock(BuildingBlockClass: typeof BuildingBlockTemplatingBase): void {\n\tif (BuildingBlockClass.metadata.namespace !== undefined) {\n\t\tXMLPreprocessor.plugIn(\n\t\t\tnull,\n\t\t\tBuildingBlockClass.metadata.namespace,\n\t\t\tBuildingBlockClass.metadata.xmlTag || BuildingBlockClass.metadata.name\n\t\t);\n\t}\n\tif (BuildingBlockClass.metadata.publicNamespace !== undefined) {\n\t\tXMLPreprocessor.plugIn(\n\t\t\tnull,\n\t\t\tBuildingBlockClass.metadata.publicNamespace,\n\t\t\tBuildingBlockClass.metadata.xmlTag || BuildingBlockClass.metadata.name\n\t\t);\n\t}\n}\n\nfunction createErrorXML(errorMessages: string[], xmlFragment: string, additionalData?: object, stack?: string): string {\n\tconst errorLabels = errorMessages.map((errorMessage) => xml`<m:Label text=\"${escapeXMLAttributeValue(errorMessage)}\"/>`);\n\tlet errorStack = \"\";\n\tif (stack) {\n\t\tconst stackFormatted = btoa(`<pre>${stack}</pre>`);\n\t\terrorStack = xml`<m:FormattedText htmlText=\"{= BBF.base64Decode('${stackFormatted}') }\" />`;\n\t}\n\tlet additionalText = \"\";\n\tif (additionalData) {\n\t\tadditionalText = xml`<m:VBox>\n\t\t\t\t\t\t<m:Label text=\"Trace Info\"/>\n\t\t\t\t\t\t<code:CodeEditor type=\"json\"  value=\"${`{= BBF.base64Decode('${btoa(JSON.stringify(additionalData, null, 4))}') }`}\" height=\"300px\" />\n\t\t\t\t\t</m:VBox>`;\n\t}\n\treturn xml`<controls:FormElementWrapper xmlns:controls=\"sap.fe.core.controls\">\n\t\t\t\t\t<m:VBox xmlns:m=\"sap.m\" xmlns:code=\"sap.ui.codeeditor\" core:require=\"{BBF:'sap/fe/core/buildingBlocks/templating/BuildingBlockFormatter'}\">\n\t\t\t\t\t${errorLabels}\n\t\t\t\t\t${errorStack}\n\t\t\t\t\t\t<grid:CSSGrid gridTemplateRows=\"fr\" gridTemplateColumns=\"repeat(2,1fr)\" gridGap=\"1rem\" xmlns:grid=\"sap.ui.layout.cssgrid\" >\n\t\t\t\t\t\t\t<m:VBox>\n\t\t\t\t\t\t\t\t<m:Label text=\"How the building block was called\"/>\n\t\t\t\t\t\t\t\t<code:CodeEditor type=\"xml\" value=\"${`{= BBF.base64Decode('${btoa(xmlFragment.replaceAll(\"&gt;\", \">\"))}') }`}\" height=\"300px\" />\n\t\t\t\t\t\t\t</m:VBox>\n\t\t\t\t\t\t\t${additionalText}\n\t\t\t\t\t\t</grid:CSSGrid>\n\t\t\t\t\t</m:VBox>\n\t\t\t\t</controls:FormElementWrapper>`;\n}\n\nconst temporaryObjectStore: Record<string, unknown> = {};\n\n/**\n * Stores an object value in a temporary storage and returns an ID used to retrieve this value at a later point in time.\n *\n * Required as there is functionality like the xml` function, which might take objects as parameters but needs to return a serialized string.\n * @param value Value to store\n * @returns ID to retrieve this value\n */\nexport function storeObjectValue(value: unknown): string {\n\tconst propertyUID = `/uid--${uid()}`;\n\ttemporaryObjectStore[propertyUID] = value;\n\treturn propertyUID;\n}\n\n/**\n * Unstores an object from a temporary store by removing it and returning its object value.\n * @param propertyUID ID to retrieve this value\n * @returns Object value\n */\nfunction unstoreObjectValue(propertyUID: string): unknown {\n\tconst value = temporaryObjectStore[propertyUID];\n\tdelete temporaryObjectStore[propertyUID];\n\treturn value;\n}\n\nlet processNextXmlInTrace = false;\n/**\n * Makes sure that all xml` calls inside the given method are processed in trace mode.\n * @param method The method to execute\n * @returns The return value of the given method\n */\nconst processXmlInTrace = async function (method: (...args: unknown[]) => Promise<unknown>): Promise<unknown> {\n\tprocessNextXmlInTrace = true;\n\tlet returnValue;\n\ttry {\n\t\treturnValue = method();\n\t} finally {\n\t\tprocessNextXmlInTrace = false;\n\t}\n\treturn returnValue;\n};\n\n/**\n * Parse an XML string and return the associated document.\n * @param xmlString The xml string\n * @param [addDefaultNamespaces] Whether or not default namespaces should be added\n * @returns The XML document.\n */\nexport function parseXMLString(xmlString: string, addDefaultNamespaces = false): Element[] {\n\tif (addDefaultNamespaces) {\n\t\txmlString = `<template\n\t\t\t\t\t\txmlns:template=\"http://schemas.sap.com/sapui5/extension/sap.ui.core.template/1\"\n\t\t\t\t\t\txmlns:m=\"sap.m\"\n\t\t\t\t\t\txmlns:macros=\"sap.fe.macros\"\n\t\t\t\t\t\txmlns:core=\"sap.ui.core\"\n\t\t\t\t\t\txmlns:mdc=\"sap.ui.mdc\"\n\t\t\t\t\t\txmlns:customData=\"http://schemas.sap.com/sapui5/extension/sap.ui.core.CustomData/1\">${xmlString}</template>`;\n\t}\n\tconst xmlDocument = DOMParserInstance.parseFromString(xmlString, \"text/xml\");\n\tlet output = xmlDocument.firstElementChild;\n\twhile (output?.localName === \"template\") {\n\t\toutput = output.firstElementChild;\n\t}\n\tconst children = output?.parentElement ? output?.parentElement.children : [output as Element];\n\treturn Array.from(children);\n}\n\n/**\n * Escape an XML attribute value.\n * @param value The attribute value to escape.\n * @returns The escaped string.\n */\nexport function escapeXMLAttributeValue(value?: string): string | undefined {\n\treturn value?.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&apos;\");\n}\n\nfunction renderInTraceMode(outStr: string): string {\n\tconst xmlResult = parseXMLString(outStr, true);\n\tif (xmlResult?.length > 0 && xmlResult[0]?.localName === \"parsererror\") {\n\t\tconst errorMessage = (xmlResult[0] as HTMLElement).innerText || (xmlResult[0] as HTMLElement).innerHTML;\n\t\treturn createErrorXML([errorMessage.split(\"\\n\")[0]], outStr);\n\t} else {\n\t\treturn outStr;\n\t}\n}\n\nexport type XMLProcessorTypeValue =\n\t| string\n\t| boolean\n\t| number\n\t| undefined\n\t| null\n\t| object\n\t| Record<string, unknown>\n\t| BindingToolkitExpression<string | boolean | number>\n\t| Array<string>\n\t| Array<Function>\n\t| Function\n\t| Context;\n/**\n * Create a string representation of the template literal while handling special object case.\n * @param strings The string parts of the template literal\n * @param values The values part of the template literal\n * @returns The XML string document representing the string that was used.\n */\nexport const xml = (strings: TemplateStringsArray, ...values: XMLProcessorTypeValue[]): string => {\n\tlet outStr = \"\";\n\tlet i;\n\tfor (i = 0; i < values.length; i++) {\n\t\toutStr += strings[i];\n\n\t\t// Handle the different case of object, if it's an array we join them, if it's a binding expression then we compile it.\n\t\tconst value = values[i];\n\n\t\tif (Array.isArray(value) && value.length > 0 && typeof value[0] === \"string\") {\n\t\t\toutStr += value.flat(5).join(\"\\n\").trim();\n\t\t} else if (isFunctionArray(value)) {\n\t\t\toutStr += value.map((valuefn) => valuefn()).join(\"\\n\");\n\t\t} else if (isBindingToolkitExpression(value)) {\n\t\t\tconst compiledExpression = compileExpression(value);\n\t\t\toutStr += escapeXMLAttributeValue(compiledExpression);\n\t\t} else if (typeof value === \"undefined\") {\n\t\t\toutStr += \"{this>undefinedValue}\";\n\t\t} else if (typeof value === \"function\") {\n\t\t\toutStr += value();\n\t\t} else if (typeof value === \"object\" && value !== null) {\n\t\t\tif (isContext(value)) {\n\t\t\t\toutStr += value.getPath();\n\t\t\t} else {\n\t\t\t\tconst propertyUId = storeObjectValue(value);\n\t\t\t\toutStr += `${propertyUId}`;\n\t\t\t}\n\t\t} else if (value && typeof value === \"string\" && !value.startsWith(\"<\") && !value.startsWith(\"&lt;\")) {\n\t\t\toutStr += escapeXMLAttributeValue(value);\n\t\t} else {\n\t\t\toutStr += value;\n\t\t}\n\t}\n\toutStr += strings[i];\n\toutStr = outStr.trim();\n\tif (processNextXmlInTrace) {\n\t\treturn renderInTraceMode(outStr);\n\t}\n\treturn outStr;\n};\n\nexport const addConditionallyToXML = function (condition: boolean, partToAdd: string): string {\n\tif (condition) {\n\t\treturn partToAdd;\n\t} else {\n\t\treturn \"\";\n\t}\n};\n\n/**\n * Add an attribute depending on the current value of the property.\n * If it's undefined the attribute is not added.\n * @param attributeName\n * @param value\n * @returns The attribute to add if the value is not undefined, otherwise an empty string\n */\nexport const addAttributeToXML = function (attributeName: string, value?: XMLProcessorTypeValue): () => string {\n\tif (value !== undefined && !isUndefinedExpression(value)) {\n\t\treturn () => xml`${attributeName}=\"${value}\"`;\n\t} else {\n\t\treturn () => \"\";\n\t}\n};\n"],"mappings":"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","ignoreList":[]}