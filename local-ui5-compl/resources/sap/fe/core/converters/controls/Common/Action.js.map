{"version":3,"file":"Action.js","names":["ButtonType","_exports","getVisibilityEnablementMenuActions","actions","menuActionNotVisible","menuActionVisiblePaths","atleastOneMenuItemsVisible","menuItemsVisiblePaths","forEach","menuAction","visible","valueOf","push","menu","length","menuItem","menuItemVisible","toString","visibleExpressions","map","menuItemVisiblePath","resolveBindingString","compileExpression","and","or","mapActionByKey","manifestActions","annotationActions","actionKey","annotationAction","find","action","key","manifestAction","resultAction","Object","keys","filter","actionAnnotation","type","ActionType","Menu","enabled","prop","propKey","canBeMenuItem","DataFieldForAction","DataFieldForIntentBasedNavigation","mapMenuDefaultAction","commandActions","defaultAction","command","mapMenuItems","mappedMenuItems","matchingAnnotationAction","menuItemKey","mappedMenuAction","transformMenuActionsAndIdentifyCommands","allActions","actionKeysToDelete","undefined","_getManifestEnabled","isAnnotationAction","converterContext","forContextMenu","arguments","result","getManifestActionBooleanPropertyWithFormatter","internalModelProperty","ifElse","requiresSelection","enableOnSelect","equal","pathInModel","greaterOrEqual","_getManifestVisible","overrideManifestConfigurationWithAnnotation","annotationPath","press","visibleForContextMenu","getActionsFromManifest","navigationSettings","considerNavigationSettings","hiddenActions","facetName","lastDotIndex","lastIndexOf","id","startsWith","getCustomActionID","Default","enabledForContextMenu","handlerModule","substring","replace","handlerMethod","text","noWrap","__noWrap","replaceSpecialChars","defaultValuesExtensionFunction","defaultValuesFunction","position","anchor","placement","Placement","After","isNavigable","isActionNavigable","enableAutoScroll","inline","propertyValue","resolvedBinding","isConstant","value","constant","methodPath","formatResult","fpmFormatter","customBooleanPropertyCheck","getDataModelObjectPath","contextLocation","targetEntityType","getEntityType","removeDuplicateActions","oMenuItemKeys","actionMenu","reduce","item","_ref","getEnabledForAnnotationAction","actionTarget","pathFromContextLocation","annotations","Core","OperationAvailable","dataModelObjectPath","isEnabledExp","getActionEnabledExpression","getConvertedTypes","getSemanticObjectMapping","mappings","mapping","LocalProperty","$PropertyPath","SemanticObjectProperty","bIsNavigationConfigured","detailOrDisplay","detail","display","route","afterExecution","navigateToInstance","dataFieldIsCopyAction","dataField","UI","IsCopyAction","$Type","getCopyAction","copyDataFields","Log","error","getAnnotationMenuActionItems","menuActionItems","getMatchingManifestAction","annotationMenuItems","matchingManifestActions","prepareMenuActions","unpreparedActions","overrideMenuActions","foundAction","menuItemIndex","overrideMenuAction","splice"],"sources":["./Action.ts"],"sourcesContent":["import type { Action } from \"@sap-ux/vocabularies-types\";\nimport type { SemanticObjectMappingType } from \"@sap-ux/vocabularies-types/vocabularies/Common\";\nimport type { DataFieldForActionGroupTypes, DataFieldForActionTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport Log from \"sap/base/Log\";\nimport type { BindingToolkitExpression, CompiledBindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport {\n\tand,\n\tcompileExpression,\n\tconstant,\n\tequal,\n\tformatResult,\n\tgreaterOrEqual,\n\tifElse,\n\tisConstant,\n\tor,\n\tpathInModel,\n\tresolveBindingString\n} from \"sap/fe/base/BindingToolkit\";\nimport type {\n\tCustomDefinedTableColumnForOverride,\n\tManifestAction,\n\tNavigationSettingsConfiguration\n} from \"sap/fe/core/converters/ManifestSettings\";\nimport { ActionType } from \"sap/fe/core/converters/ManifestSettings\";\nimport type { PageContextPathTarget } from \"sap/fe/core/converters/TemplateConverter\";\nimport type { ConfigurableObject, CustomElement, OverrideType } from \"sap/fe/core/converters/helpers/ConfigurableObject\";\nimport { Placement } from \"sap/fe/core/converters/helpers/ConfigurableObject\";\nimport { getCustomActionID } from \"sap/fe/core/converters/helpers/ID\";\nimport fpmFormatter from \"sap/fe/core/formatters/FPMFormatter\";\nimport { replaceSpecialChars } from \"sap/fe/core/helpers/StableIdHelper\";\nimport { getActionEnabledExpression } from \"sap/fe/core/templating/UIFormatters\";\nimport type View from \"sap/ui/core/mvc/View\";\nimport type Context from \"sap/ui/model/Context\";\nimport type { MetaModelType } from \"types/metamodel_types\";\nimport type ConverterContext from \"../../ConverterContext\";\n\nexport enum ButtonType {\n\tAccept = \"Accept\",\n\tAttention = \"Attention\",\n\tBack = \"Back\",\n\tCritical = \"Critical\",\n\tDefault = \"Default\",\n\tEmphasized = \"Emphasized\",\n\tGhost = \"Ghost\",\n\tNegative = \"Negative\",\n\tNeutral = \"Neutral\",\n\tReject = \"Reject\",\n\tSuccess = \"Success\",\n\tTransparent = \"Transparent\",\n\tUnstyled = \"Unstyled\",\n\tUp = \"Up\"\n}\n\nexport type BaseAction = ConfigurableObject & {\n\tid?: string;\n\ttext?: string;\n\ttype?: ActionType;\n\tpress?: string;\n\tenabled?: CompiledBindingToolkitExpression;\n\tenabledForContextMenu?: CompiledBindingToolkitExpression;\n\tvisible?: CompiledBindingToolkitExpression;\n\tvisibleForContextMenu?: CompiledBindingToolkitExpression;\n\tenableOnSelect?: string;\n\tannotationPath?: string;\n\tdefaultValuesExtensionFunction?: string;\n\tisNavigable?: boolean;\n\tenableAutoScroll?: boolean;\n\tparentEntityDeleteEnabled?: CompiledBindingToolkitExpression;\n\tmenu?: BaseAction[];\n\tfacetName?: string;\n\tcommand?: string | undefined;\n};\n\nexport type AnnotationAction = BaseAction & {\n\ttype: ActionType.DataFieldForIntentBasedNavigation | ActionType.DataFieldForAction | ActionType.Menu | ActionType.Copy;\n\tannotationPath: string;\n\tcustomData?: string;\n\trequiresDialog?: string;\n\tbinding?: string;\n\tbuttonType?: ButtonType.Ghost | ButtonType.Transparent | string;\n};\n\nexport type AnnotationActionActionGroup = BaseAction & {\n\t// implements DataFieldForActionGroup\n\ttype: ActionType.Menu;\n\tmenu: AnnotationAction[];\n};\n\nexport type CustomAction = CustomElement<\n\tBaseAction & {\n\t\thandlerMethod?: string;\n\t\thandlerModule?: string;\n\t\tnoWrap?: boolean; // Indicates that we want to avoid the wrapping from the FPMHelper\n\t\trequiresSelection?: boolean;\n\t\tdefaultAction?: string | BaseAction | CustomAction; // Indicates whether a default action exists in this context\n\t}\n>;\n\nexport type AnnotationActionGroup = BaseAction & {\n\t// implements DataFieldForActionGroup\n\ttype: ActionType.Menu;\n\tmenu: AnnotationAction[];\n};\n\nexport type CombinedAction = {\n\tactions: BaseAction[];\n\tcommandActions: Record<string, CustomAction>;\n};\n\nexport type OverrideTypeAction = {\n\tenableAutoScroll?: OverrideType.overwrite;\n\tdefaultValuesExtensionFunction?: OverrideType.overwrite;\n\tisNavigable?: OverrideType.overwrite;\n\tenableOnSelect?: OverrideType.overwrite;\n\tmenu?: OverrideType.overwrite;\n\n\t// Can be overwritten by manifest configuration and should be aligned for all actions\n\tenabled: OverrideType.overwrite;\n\tvisible: OverrideType.overwrite;\n\tvisibleForContextMenu?: OverrideType.overwrite;\n\tcommand: OverrideType.overwrite;\n\tposition: OverrideType.overwrite;\n};\n\nexport type DataFieldForActionOrActionGroup = DataFieldForActionTypes | DataFieldForActionGroupTypes;\n\ntype MenuAction =\n\t| BaseAction\n\t| {\n\t\t\tvisible?: string[];\n\t\t\tenabled?: string[];\n\t\t\tmenu?: BaseAction[];\n\t  };\n/**\n * Method provides actions collection after calculating the visible setting for all actions of type menu depending on its visible setting and its menu items visible settings.\n * @param actions Collection of actions\n * @returns Collection of actions with visible setting set for actions of type menu\n */\nexport const getVisibilityEnablementMenuActions = (actions: CustomAction[]): CustomAction[] => {\n\tlet menuActionNotVisible: string | boolean,\n\t\tmenuActionVisiblePaths: string[],\n\t\tatleastOneMenuItemsVisible: boolean,\n\t\tmenuItemsVisiblePaths: string[];\n\tactions.forEach((menuAction: MenuAction) => {\n\t\tmenuActionNotVisible = menuAction.visible?.valueOf() === \"false\";\n\t\tatleastOneMenuItemsVisible = false;\n\t\tmenuItemsVisiblePaths = [];\n\t\tmenuActionVisiblePaths = [];\n\t\tif (menuAction.visible && !(menuAction.visible.valueOf() === \"true\" || menuAction.visible.valueOf() === \"false\")) {\n\t\t\tmenuActionVisiblePaths.push(menuAction.visible as string);\n\t\t}\n\t\tif (menuAction?.menu?.length) {\n\t\t\tmenuAction?.menu?.forEach((menuItem: BaseAction): void => {\n\t\t\t\tconst menuItemVisible = menuItem.visible;\n\t\t\t\tif (menuItemVisible && (typeof menuItemVisible === \"boolean\" || menuItemVisible.valueOf() === \"true\")) {\n\t\t\t\t\tatleastOneMenuItemsVisible = true;\n\t\t\t\t} else if (menuItemVisible && menuItemVisible.valueOf() !== \"false\") {\n\t\t\t\t\tmenuItemsVisiblePaths.push(menuItemVisible.valueOf());\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (menuActionNotVisible) {\n\t\t\t\t// if menu is statically visible false\n\t\t\t\tmenuAction.visible = false.toString();\n\t\t\t} else if (!atleastOneMenuItemsVisible && !menuItemsVisiblePaths.length) {\n\t\t\t\t// if all menu items are statically visible false\n\t\t\t\tmenuAction.visible = false.toString();\n\t\t\t} else if (atleastOneMenuItemsVisible && !menuActionVisiblePaths.length) {\n\t\t\t\t// if at least one menu item is statically visible true and no visible setting for menu\n\t\t\t\tmenuAction.visible = true.toString();\n\t\t\t} else if (menuActionVisiblePaths.length || menuItemsVisiblePaths.length) {\n\t\t\t\t// If the menu is set to invisible, it should be invisible, otherwise the visibility should be calculated from the items\n\t\t\t\tconst visibleExpressions: BindingToolkitExpression<boolean>[] = menuItemsVisiblePaths.map((menuItemVisiblePath) =>\n\t\t\t\t\tresolveBindingString(menuItemVisiblePath, \"boolean\")\n\t\t\t\t);\n\t\t\t\tmenuAction.visible = compileExpression(\n\t\t\t\t\tand(resolveBindingString((menuAction.visible as string) || true, \"boolean\"), or(...visibleExpressions))\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmenuAction.visible = (!menuActionNotVisible).toString();\n\t\t\t}\n\t\t}\n\t});\n\treturn actions;\n};\n\n/**\n * Maps an action by its key, based on the given annotation actions and manifest configuration. The result already represents the\n * merged action from both configuration sources.\n *\n * This function also returns an indication whether the action can be a menu item, saying whether it is visible or of a specific type\n * that allows this.\n * @param manifestActions Actions defined in the manifest\n * @param annotationActions Actions defined through annotations\n * @param actionKey Action Key to look up\n * @returns Merged action and indicator whether it can be a menu item\n */\nfunction mapActionByKey(\n\tmanifestActions: Record<string, PartiallyConvertedCustomAction>,\n\tannotationActions: BaseAction[],\n\tactionKey: string\n): { action: BaseAction | CustomAction; canBeMenuItem: boolean | CompiledBindingToolkitExpression } {\n\tconst annotationAction = annotationActions.find((action) => action.key === actionKey);\n\tconst manifestAction = manifestActions[actionKey];\n\tlet resultAction: PartiallyConvertedCustomAction | BaseAction = { ...(annotationAction ?? manifestAction) };\n\n\t// actions inside menus can't be found on top level, so assign actions from menu to it\n\tif (Object.keys(resultAction).length === 0) {\n\t\tannotationActions\n\t\t\t.filter((actionAnnotation: BaseAction) => {\n\t\t\t\treturn actionAnnotation.type === ActionType.Menu;\n\t\t\t})\n\t\t\t.forEach((menuAction: BaseAction) => {\n\t\t\t\tmenuAction.menu?.forEach((menuItem: BaseAction) => {\n\t\t\t\t\tif (menuItem.key === actionKey) {\n\t\t\t\t\t\tresultAction = menuItem;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t}\n\n\t// Annotation action and manifest configuration already has to be merged here as insertCustomElements only considers top-level actions\n\tif (annotationAction) {\n\t\t// If enabled or visible is not set in the manifest, use the annotation value and hence do not overwrite\n\t\tresultAction.enabled = manifestAction?.enabled ?? annotationAction.enabled;\n\t\tresultAction.visible = manifestAction?.visible ?? annotationAction.visible;\n\n\t\tfor (const prop in manifestAction || {}) {\n\t\t\tconst propKey = prop as keyof BaseAction;\n\t\t\tif (!annotationAction[propKey] && propKey !== \"menu\") {\n\t\t\t\tresultAction[propKey] = manifestAction[propKey] as never;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst canBeMenuItem =\n\t\tresultAction?.visible ||\n\t\tresultAction?.type === ActionType.DataFieldForAction ||\n\t\tresultAction?.type === ActionType.DataFieldForIntentBasedNavigation;\n\n\treturn {\n\t\taction: resultAction as BaseAction | CustomAction,\n\t\tcanBeMenuItem\n\t};\n}\n\n/**\n * Map the default action key of a menu to its actual action configuration and identify whether this default action is a command.\n * @param menuAction Menu action to map the default action for\n * @param manifestActions Actions defined in the manifest\n * @param annotationActions Actions defined through annotations\n * @param commandActions Array of command actions to push the default action to if applicable\n */\nfunction mapMenuDefaultAction(\n\tmenuAction: PartiallyConvertedCustomAction,\n\tmanifestActions: Record<string, PartiallyConvertedCustomAction>,\n\tannotationActions: BaseAction[],\n\tcommandActions: Record<string, CustomAction | BaseAction>\n): void {\n\tconst { action, canBeMenuItem } = mapActionByKey(manifestActions, annotationActions, menuAction.defaultAction as string);\n\n\tif (canBeMenuItem) {\n\t\tmenuAction.defaultAction = action;\n\t}\n\n\tif (action.command) {\n\t\tcommandActions[action.key] = action;\n\t}\n}\n\n/**\n * Map the menu item keys of a menu to their actual action configurations and identify whether they are commands.\n * @param menuAction Menu action to map the menu items for\n * @param manifestActions Actions defined in the manifest\n * @param annotationActions Actions defined through annotations\n * @param commandActions Array of command actions to push the menu item actions to if applicable\n */\nfunction mapMenuItems(\n\tmenuAction: PartiallyConvertedCustomAction,\n\tmanifestActions: Record<string, PartiallyConvertedCustomAction>,\n\tannotationActions: BaseAction[],\n\tcommandActions: Record<string, BaseAction | CustomAction>\n): void {\n\tconst mappedMenuItems: (CustomAction | BaseAction)[] = [];\n\tconst matchingAnnotationAction = annotationActions.find((annotationAction) => annotationAction.key === menuAction.key);\n\n\tif (menuAction.menu?.length !== 0) {\n\t\tfor (const menuItemKey of menuAction.menu ?? []) {\n\t\t\tconst { action, canBeMenuItem } = mapActionByKey(manifestActions, annotationActions, menuItemKey);\n\n\t\t\tif (canBeMenuItem) {\n\t\t\t\tmappedMenuItems.push(action);\n\t\t\t}\n\n\t\t\tif (action.command) {\n\t\t\t\tcommandActions[menuItemKey] = action;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If no menu items are assigned to the manifest-override-menu, it inherits the items from the previous menu\n\telse if (matchingAnnotationAction) {\n\t\tmatchingAnnotationAction.menu?.forEach((menuItem) => mappedMenuItems.push(menuItem));\n\t}\n\n\tconst mappedMenuAction = menuAction as CustomAction;\n\tmappedMenuAction.menu = mappedMenuItems;\n\n\t// If the menu is set to invisible, it should be invisible, otherwise the visibility should be calculated from the items\n\tconst visibleExpressions: BindingToolkitExpression<boolean>[] = mappedMenuItems.map((menuItem) =>\n\t\tresolveBindingString(menuItem.visible as string, \"boolean\")\n\t);\n\tmappedMenuAction.visible = compileExpression(\n\t\tand(resolveBindingString(menuAction.visible as string, \"boolean\"), or(...visibleExpressions))\n\t);\n}\n\n/**\n * Transforms the flat collection of actions into a nested structures of menus. The result is a record of actions that are either menus or\n * ones that do not appear in menus as menu items. It also returns a list of actions that have an assigned command.\n *\n * Note that menu items are already the merged result of annotation actions and their manifest configuration, as {@link insertCustomElements}\n * only considers root-level actions.\n * @param manifestActions Actions defined in the manifest\n * @param annotationActions Actions defined through annotations\n * @returns The transformed actions from the manifest and a list of command actions\n */\nfunction transformMenuActionsAndIdentifyCommands(\n\tmanifestActions: Record<string, PartiallyConvertedCustomAction>,\n\tannotationActions: BaseAction[]\n): Record<string, Record<string, CustomAction>> {\n\tconst allActions: Record<string, CustomAction> = {};\n\tconst actionKeysToDelete: string[] = [];\n\tconst commandActions: Record<string, CustomAction> = {};\n\n\tfor (const actionKey in manifestActions) {\n\t\tconst manifestAction: PartiallyConvertedCustomAction = manifestActions[actionKey];\n\n\t\tif (manifestAction.defaultAction !== undefined) {\n\t\t\tmapMenuDefaultAction(manifestAction, manifestActions, annotationActions, commandActions);\n\t\t}\n\n\t\tif (manifestAction.type === ActionType.Menu) {\n\t\t\tmapMenuItems(manifestAction, manifestActions, annotationActions, commandActions);\n\n\t\t\t// Menu has no visible items, so remove it\n\t\t\tif (!manifestAction.menu?.length) {\n\t\t\t\tactionKeysToDelete.push(manifestAction.key);\n\t\t\t}\n\t\t}\n\n\t\tif (manifestAction.command) {\n\t\t\tcommandActions[actionKey] = manifestAction as CustomAction;\n\t\t}\n\n\t\tallActions[actionKey] = manifestAction as CustomAction;\n\t}\n\n\tactionKeysToDelete.forEach((actionKey: string) => delete allActions[actionKey]);\n\n\treturn {\n\t\tactions: allActions,\n\t\tcommandActions: commandActions\n\t};\n}\n\n/**\n * Gets the binding expression for the enablement of a manifest action.\n * @param manifestAction The action configured in the manifest\n * @param isAnnotationAction Whether the action, defined in manifest, corresponds to an existing annotation action.\n * @param converterContext\n * @param forContextMenu\n * @returns Determined property value for the enablement\n */\nconst _getManifestEnabled = function (\n\tmanifestAction: ManifestAction,\n\tisAnnotationAction: boolean,\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tforContextMenu = false\n): CompiledBindingToolkitExpression | undefined {\n\tif (isAnnotationAction && manifestAction.enabled === undefined) {\n\t\t// If annotation action has no property defined in manifest,\n\t\t// do not overwrite it with manifest action's default value.\n\t\treturn undefined;\n\t}\n\n\tconst result = getManifestActionBooleanPropertyWithFormatter(manifestAction.enabled, converterContext);\n\n\t// Consider requiresSelection property to include selectedContexts in the binding expression\n\tconst internalModelProperty = !forContextMenu ? \"numberOfSelectedContexts\" : \"contextmenu/numberOfSelectedContexts\";\n\treturn compileExpression(\n\t\tifElse(\n\t\t\tmanifestAction.requiresSelection === true,\n\t\t\tifElse(\n\t\t\t\tmanifestAction.enableOnSelect === \"single\",\n\t\t\t\tand(equal(pathInModel(internalModelProperty, \"internal\"), 1), result),\n\t\t\t\tand(greaterOrEqual(pathInModel(internalModelProperty, \"internal\"), 1), result)\n\t\t\t),\n\t\t\tresult\n\t\t)\n\t);\n};\n\n/**\n * Gets the binding expression for the visibility of a manifest action.\n * @param manifestAction The action configured in the manifest\n * @param isAnnotationAction Whether the action, defined in the manifest, corresponds to an existing annotation action.\n * @param converterContext\n * @param forContextMenu\n * @returns Determined property value for the visibility\n */\nconst _getManifestVisible = function (\n\tmanifestAction: ManifestAction,\n\tisAnnotationAction: boolean,\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tforContextMenu = false\n): CompiledBindingToolkitExpression | undefined {\n\tif (isAnnotationAction && manifestAction.visible === undefined) {\n\t\t// If annotation action has no property defined in manifest,\n\t\t// do not overwrite it with manifest action's default value.\n\t\treturn undefined;\n\t}\n\n\tlet result = getManifestActionBooleanPropertyWithFormatter(manifestAction.visible, converterContext);\n\t// For the context menu, the visibility should also consider the 'inactiveContext' property:\n\t// only when at least one selected context is active (i.e. \"contextmenu/inactiveContext\" is false), the action should be visible in the context menu\n\t// This is only relevant when the table manifest setting \"creationMode\" is \"InlineCreationRows\"\n\tresult = forContextMenu ? and(result, equal(pathInModel(\"contextmenu/inactiveContext\", \"internal\"), false)) : result;\n\treturn compileExpression(result);\n};\n\ntype PartiallyConvertedCustomAction = Omit<CustomAction, \"menu\"> & { menu: string[] | undefined };\n\n/**\n * As some properties should not be overridable by the manifest, make sure that the manifest configuration gets the annotation values for these.\n * @param manifestAction Action defined in the manifest\n * @param annotationAction Action defined through annotations\n */\nfunction overrideManifestConfigurationWithAnnotation(manifestAction: PartiallyConvertedCustomAction, annotationAction?: BaseAction): void {\n\tif (!annotationAction) {\n\t\treturn;\n\t}\n\n\t// Do not override the 'type' given in an annotation action\n\tmanifestAction.type = annotationAction.type;\n\tmanifestAction.annotationPath = annotationAction.annotationPath;\n\tmanifestAction.press = annotationAction.press;\n\n\t// Only use the annotation values for enablement and visibility if not set in the manifest\n\tmanifestAction.enabled = manifestAction.enabled ?? annotationAction.enabled;\n\tmanifestAction.visible = manifestAction.visible ?? annotationAction.visible;\n\tmanifestAction.visibleForContextMenu = manifestAction.visibleForContextMenu ?? annotationAction.visibleForContextMenu;\n}\n\n/**\n * Creates the action configuration based on the manifest settings.\n * @param manifestActions The manifest actions\n * @param converterContext The converter context\n * @param annotationActions The annotation actions definition\n * @param navigationSettings The navigation settings\n * @param considerNavigationSettings The navigation settings to be considered\n * @param hiddenActions Actions that are configured as hidden (additional to the visible property)\n * @param facetName The facet where an action is displayed if it is inline\n * @returns The actions from the manifest\n */\nexport function getActionsFromManifest(\n\tmanifestActions: Record<string, ManifestAction> | undefined,\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tannotationActions?: BaseAction[],\n\tnavigationSettings?: NavigationSettingsConfiguration,\n\tconsiderNavigationSettings?: boolean,\n\thiddenActions?: BaseAction[],\n\tfacetName?: string\n): Record<string, Record<string, CustomAction>> {\n\tconst actions: Record<string, PartiallyConvertedCustomAction> = {};\n\tfor (const actionKey in manifestActions) {\n\t\tconst manifestAction: ManifestAction = manifestActions[actionKey];\n\t\tconst lastDotIndex = manifestAction.press?.lastIndexOf(\".\") || -1;\n\t\tlet annotationAction: BaseAction | undefined;\n\n\t\tif (annotationActions) {\n\t\t\tfor (const action of annotationActions) {\n\t\t\t\t// SubSection.ts#createFormActionReducer uses insertCustomElements which results in annotation actions mixing up with manifest action\n\t\t\t\t// this is why we may find an action that has a CustomAction prefix\n\t\t\t\tif (action.id?.startsWith(\"CustomAction::\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (action.key === actionKey) {\n\t\t\t\t\tannotationAction = action;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (action.type === \"Menu\") {\n\t\t\t\t\t// If not found, check inside menus\n\t\t\t\t\tannotationAction = action.menu?.find((menuItem: BaseAction) => {\n\t\t\t\t\t\treturn menuItem.key === actionKey;\n\t\t\t\t\t});\n\t\t\t\t\tif (annotationAction) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// To identify the annotation action property overwrite via manifest use-case.\n\t\tconst isAnnotationAction = !!annotationAction;\n\t\tif (manifestAction.facetName) {\n\t\t\tfacetName = manifestAction.facetName;\n\t\t}\n\n\t\tactions[actionKey] = {\n\t\t\tid: annotationAction ? actionKey : getCustomActionID(actionKey),\n\t\t\ttype: manifestAction.menu ? ActionType.Menu : ActionType.Default,\n\t\t\tvisible: _getManifestVisible(manifestAction, isAnnotationAction, converterContext),\n\t\t\tvisibleForContextMenu: _getManifestVisible(manifestAction, isAnnotationAction, converterContext, true),\n\t\t\tenabled: _getManifestEnabled(manifestAction, isAnnotationAction, converterContext),\n\t\t\tenabledForContextMenu: _getManifestEnabled(manifestAction, isAnnotationAction, converterContext, true),\n\t\t\thandlerModule: manifestAction.press && manifestAction.press.substring(0, lastDotIndex).replace(/\\./gi, \"/\"),\n\t\t\thandlerMethod: manifestAction.press && manifestAction.press.substring(lastDotIndex + 1),\n\t\t\tpress: manifestAction.press,\n\t\t\ttext: manifestAction.text,\n\t\t\tnoWrap: manifestAction.__noWrap,\n\t\t\tkey: replaceSpecialChars(actionKey),\n\t\t\tenableOnSelect: manifestAction.enableOnSelect,\n\t\t\tdefaultValuesExtensionFunction: manifestAction.defaultValuesFunction,\n\t\t\tposition: {\n\t\t\t\tanchor: manifestAction.position?.anchor,\n\t\t\t\tplacement: manifestAction.position === undefined ? Placement.After : manifestAction.position.placement\n\t\t\t},\n\t\t\tisNavigable: isActionNavigable(manifestAction, navigationSettings, considerNavigationSettings),\n\t\t\tcommand: manifestAction.command,\n\t\t\trequiresSelection: manifestAction.requiresSelection === undefined ? false : manifestAction.requiresSelection,\n\t\t\tenableAutoScroll: enableAutoScroll(manifestAction),\n\t\t\tmenu: manifestAction.menu ?? (annotationAction?.type === ActionType.Menu ? [] : undefined),\n\t\t\tfacetName: manifestAction.inline ? facetName : undefined,\n\t\t\tdefaultAction: manifestAction.defaultAction\n\t\t};\n\n\t\toverrideManifestConfigurationWithAnnotation(actions[actionKey], annotationAction);\n\t}\n\n\treturn transformMenuActionsAndIdentifyCommands(actions, annotationActions ?? []);\n}\n\n/**\n * Gets a binding expression representing a Boolean manifest property that can either be represented by a static value, a binding string,\n * or a runtime formatter function.\n * @param propertyValue String representing the configured property value\n * @param converterContext\n * @returns A binding expression representing the property\n */\nfunction getManifestActionBooleanPropertyWithFormatter(\n\tpropertyValue: string | undefined | boolean,\n\tconverterContext: ConverterContext<PageContextPathTarget>\n): BindingToolkitExpression<boolean> {\n\tconst resolvedBinding = resolveBindingString<boolean | string>(propertyValue as string, \"boolean\");\n\tlet result: BindingToolkitExpression<boolean>;\n\tif (isConstant(resolvedBinding) && resolvedBinding.value === undefined) {\n\t\t// No property value configured in manifest for the custom action --> default value is true\n\t\tresult = constant(true);\n\t} else if (isConstant(resolvedBinding) && typeof resolvedBinding.value === \"string\") {\n\t\t// Then it's a module-method reference \"sap.xxx.yyy.doSomething\"\n\t\tconst methodPath = resolvedBinding.value;\n\t\t// FIXME: The custom \"isEnabled\" check does not trigger (because none of the bound values changes)\n\t\tresult = formatResult(\n\t\t\t[pathInModel<View>(\"/\", \"$view\"), methodPath, pathInModel<Context[]>(\"selectedContexts\", \"internal\")],\n\t\t\tfpmFormatter.customBooleanPropertyCheck,\n\t\t\tconverterContext.getDataModelObjectPath().contextLocation?.targetEntityType || converterContext.getEntityType()\n\t\t);\n\t} else {\n\t\t// then it's a binding\n\t\tresult = resolvedBinding as BindingToolkitExpression<boolean>;\n\t}\n\n\treturn result;\n}\n\nexport const removeDuplicateActions = (actions: CustomAction[]): CustomAction[] => {\n\tlet oMenuItemKeys: Record<string, boolean> = {};\n\tactions.forEach((action) => {\n\t\tif (action?.menu?.length) {\n\t\t\tconst actionMenu = action.menu;\n\t\t\toMenuItemKeys = actionMenu.reduce((item: Record<string, boolean>, { key }) => {\n\t\t\t\tif (key && !item[key]) {\n\t\t\t\t\titem[key] = true;\n\t\t\t\t}\n\t\t\t\treturn item;\n\t\t\t}, oMenuItemKeys);\n\t\t}\n\t});\n\treturn actions.filter((action) => !oMenuItemKeys[action.key]);\n};\n\n/**\n * Method to determine the value of the 'enabled' property of an annotation-based action.\n * @param converterContext The instance of the converter context\n * @param actionTarget The instance of the action\n * @param pathFromContextLocation Is the binding path calculated  from the converter context location\n * @returns The binding expression for the 'enabled' property of the action button.\n */\nexport function getEnabledForAnnotationAction(\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tactionTarget: Action | undefined,\n\tpathFromContextLocation = false\n): CompiledBindingToolkitExpression {\n\tif (actionTarget?.annotations.Core?.OperationAvailable) {\n\t\tconst dataModelObjectPath = converterContext.getDataModelObjectPath();\n\t\tconst isEnabledExp = getActionEnabledExpression(\n\t\t\tactionTarget,\n\t\t\tconverterContext.getConvertedTypes(),\n\t\t\tdataModelObjectPath,\n\t\t\tpathFromContextLocation\n\t\t);\n\t\treturn compileExpression(isEnabledExp);\n\t}\n\treturn \"true\";\n}\n\nexport function getSemanticObjectMapping(mappings?: SemanticObjectMappingType[]): MetaModelType<SemanticObjectMappingType>[] {\n\treturn mappings\n\t\t? mappings.map((mapping) => {\n\t\t\t\treturn {\n\t\t\t\t\tLocalProperty: {\n\t\t\t\t\t\t$PropertyPath: mapping.LocalProperty.value\n\t\t\t\t\t},\n\t\t\t\t\tSemanticObjectProperty: mapping.SemanticObjectProperty.toString()\n\t\t\t\t};\n\t\t  })\n\t\t: [];\n}\n\nexport function isActionNavigable(\n\taction: ManifestAction | CustomDefinedTableColumnForOverride | undefined,\n\tnavigationSettings?: NavigationSettingsConfiguration,\n\tconsiderNavigationSettings?: boolean\n): boolean {\n\tlet bIsNavigationConfigured = true;\n\tif (considerNavigationSettings) {\n\t\tconst detailOrDisplay = navigationSettings && (navigationSettings.detail || navigationSettings.display);\n\t\tbIsNavigationConfigured = detailOrDisplay?.route ? true : false;\n\t}\n\t// when enableAutoScroll is true the navigateToInstance feature is disabled\n\tif (\n\t\t(action &&\n\t\t\taction.afterExecution &&\n\t\t\t(action.afterExecution?.navigateToInstance === false || action.afterExecution?.enableAutoScroll === true)) ||\n\t\t!bIsNavigationConfigured\n\t) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nexport function enableAutoScroll(action: ManifestAction): boolean {\n\treturn action?.afterExecution?.enableAutoScroll === true;\n}\n\nexport function dataFieldIsCopyAction(dataField: DataFieldForActionTypes): boolean {\n\treturn dataField.annotations?.UI?.IsCopyAction?.valueOf() === true && dataField.$Type === UIAnnotationTypes.DataFieldForAction;\n}\n\nexport function getCopyAction(copyDataFields: DataFieldForActionTypes[]): DataFieldForActionTypes | undefined {\n\tif (copyDataFields.length === 1) {\n\t\treturn copyDataFields[0];\n\t}\n\tif (copyDataFields.length > 1) {\n\t\tLog.error(\"Multiple actions are annotated with isCopyAction. There can be only one standard copy action.\");\n\t}\n\treturn undefined;\n}\n\n/**\n * Method to extract menu items from actions of type menus.\n * @param annotationActions Collection of annotation based actions\n * @returns Collection of actions which are menu items in one of the annotation based menus\n */\nexport function getAnnotationMenuActionItems(annotationActions: BaseAction[]): BaseAction[] {\n\tconst menuActionItems: BaseAction[] = [];\n\n\tannotationActions.forEach((action: BaseAction) => {\n\t\tif (action.type === \"Menu\" && !action.id?.startsWith(\"CustomAction::\") && action.menu) {\n\t\t\tmenuActionItems.push(...action.menu);\n\t\t}\n\t});\n\n\treturn menuActionItems;\n}\n\n/**\n * Method to find the matching manifest actions which override the annotation menu items.\n * @param annotationMenuItems Collection of annotation based menu items\n * @param manifestActions Collection of manifest based actions\n * @returns Collection of actions which are menu items in one of the annotation based menus\n */\nexport function getMatchingManifestAction(\n\tannotationMenuItems: BaseAction[],\n\tmanifestActions: Record<string, CustomAction>\n): Record<string, CustomAction> {\n\tconst matchingManifestActions: Record<string, CustomAction> = {};\n\n\tfor (const manifestAction in manifestActions) {\n\t\tif (\n\t\t\tmanifestAction.startsWith(\"DataFieldForAction::\") &&\n\t\t\tannotationMenuItems.find((menuActionItems) => {\n\t\t\t\treturn menuActionItems.key === manifestAction;\n\t\t\t})\n\t\t) {\n\t\t\tmatchingManifestActions[manifestAction] = manifestActions[manifestAction];\n\t\t}\n\t}\n\n\treturn matchingManifestActions;\n}\n\n/**\n * Method to transform the menus by replacing the menu items with their overriding actions.\n * @param unpreparedActions Collection of all actions after merging manifest and annotation actions\n * @param overrideMenuActions Collection of all overriden menu items\n */\nexport function prepareMenuActions(unpreparedActions: CustomAction[], overrideMenuActions: BaseAction[]): void {\n\tlet foundAction;\n\n\tunpreparedActions.forEach((action: CustomAction) => {\n\t\tif (action.type === ActionType.Menu) {\n\t\t\taction.menu?.forEach((menuItem: BaseAction, menuItemIndex: number) => {\n\t\t\t\tfoundAction = overrideMenuActions.find((overrideMenuAction: BaseAction) => {\n\t\t\t\t\treturn overrideMenuAction.key === menuItem.key;\n\t\t\t\t});\n\n\t\t\t\tif (foundAction) {\n\t\t\t\t\taction.menu?.splice(menuItemIndex, 1, foundAction);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n}\n"],"mappings":"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","ignoreList":[]}