{"version":3,"file":"ConverterContext.js","names":["isAnnotationTerm","vAnnotationPath","getDataModelPathForEntitySet","resolvedMetaPath","convertedTypes","rootEntitySet","currentEntitySet","previousEntitySet","currentEntityType","navigatedPaths","navigationProperties","objectPath","forEach","objectPart","isServiceObject","_type","push","name","targetType","navigationPropertyBinding","hasOwnProperty","join","undefined","entityType","dataModelPath","startingEntitySet","targetEntityType","targetEntitySet","contextLocation","targetObject","target","ConverterContext","manifestSettings","diagnostics","mergeFn","targetDataModelPath","this","manifestWrapper","ManifestWrapper","baseContextPath","getTargetObjectPath","_proto","prototype","_getEntityTypeFromFullyQualifiedName","fullyQualifiedName","entityTypes","find","startsWith","replaceAnnotation","replace","getAnnotationEntityType","annotation","annotationPath","Error","getManifestControlConfiguration","getControlConfiguration","hasEntitySetKeyInManifest","getEntitySet","length","hasContextPathKeyInManifest","getContextPath","isPathAbsolute","hasMultipleEntitySets","Object","keys","getAbsoluteAnnotationPath","sAnnotationPath","getDataModelObjectPath","getEntityContainer","entityContainer","getEntityType","getParameterEntityType","parameterEntityType","isParameterized","annotations","Common","ResultContext","getEntityTypeAnnotation","includes","isAbsolute","path","base","split","endsWith","resolveAbsolutePath","dataModelObjectPath","getInvolvedDataModelObjectFromPath","visitedObjects","converterContext","getTemplateType","getConvertedTypes","getRelativeAnnotationPath","getEntitySetBasedAnnotationPath","entityTypeFQN","match","replacedAnnotationPath","substring","getManifestWrapper","getDiagnostics","resolvePath","getConverterContextFor","contextPath","targetPath","getAnnotationsByTerm","vocabularyName","annotationTerm","annotationSources","arguments","outAnnotations","annotationSource","filter","term","reduce","previousValue","key","getRelativeModelPathFunction","convertedMetaModel","sPath","singletonPath","singletonPathVisitor","enhancedPath","enhanceDataModelPath","contextRelativePath","getContextRelativeTargetObjectPath","createConverterContextForMacro","entityName","oMetaModelContext","oMetaModel","isA","getModel","oConvertedMetadata","convertTypes","entitySets","entitySet","singletons","fetchTextFromMetaModel","ModelHelper"],"sources":["./ConverterContext.ts"],"sourcesContent":["import type {\n\tAnnotationTerm,\n\tConvertedMetadata,\n\tEntityContainer,\n\tEntitySet,\n\tEntityType,\n\tNavigationProperty,\n\tResolutionTarget,\n\tServiceObject,\n\tServiceObjectAndAnnotation,\n\tSingleton\n} from \"@sap-ux/vocabularies-types\";\nimport type { RecordComplexType } from \"@sap-ux/vocabularies-types/Edm\";\nimport type { EntityTypeAnnotations } from \"@sap-ux/vocabularies-types/vocabularies/Edm_Types\";\nimport type { BaseManifestSettings, ControlManifestConfiguration, TemplateType } from \"sap/fe/core/converters/ManifestSettings\";\nimport ManifestWrapper from \"sap/fe/core/converters/ManifestWrapper\";\nimport { convertTypes, getInvolvedDataModelObjectFromPath } from \"sap/fe/core/converters/MetaModelConverter\";\nimport type { IDiagnostics, PageContextPathTarget } from \"sap/fe/core/converters/TemplateConverter\";\nimport { singletonPathVisitor } from \"sap/fe/core/helpers/BindingHelper\";\nimport ModelHelper from \"sap/fe/core/helpers/ModelHelper\";\nimport { isServiceObject } from \"sap/fe/core/helpers/TypeGuards\";\nimport type { DataModelObjectPath } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport { enhanceDataModelPath, getContextRelativeTargetObjectPath, getTargetObjectPath } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport type Context from \"sap/ui/model/Context\";\nimport type ODataMetaModel from \"sap/ui/model/odata/v4/ODataMetaModel\";\n\nexport type ResolvedAnnotationContext<T> = {\n\tannotation: AnnotationTerm<T> | undefined;\n\tconverterContext: ConverterContext<PageContextPathTarget>;\n};\n\n/**\n * Checks whether an object is an annotation term.\n * @param vAnnotationPath\n * @returns `true` if it's an annotation term\n */\nconst isAnnotationTerm = function <T>(vAnnotationPath: string | AnnotationTerm<T>): vAnnotationPath is AnnotationTerm<T> {\n\treturn typeof vAnnotationPath === \"object\";\n};\n\nconst getDataModelPathForEntitySet = function <T>(\n\tresolvedMetaPath: ResolutionTarget<T>,\n\tconvertedTypes: ConvertedMetadata\n): DataModelObjectPath<T> {\n\tlet rootEntitySet: EntitySet | undefined;\n\tlet currentEntitySet: EntitySet | undefined;\n\tlet previousEntitySet: EntitySet | undefined;\n\tlet currentEntityType: EntityType | undefined;\n\tlet navigatedPaths: string[] = [];\n\tconst navigationProperties: NavigationProperty[] = [];\n\tresolvedMetaPath.objectPath.forEach((objectPart: ServiceObjectAndAnnotation) => {\n\t\tif (isServiceObject(objectPart)) {\n\t\t\tswitch (objectPart._type) {\n\t\t\t\tcase \"NavigationProperty\":\n\t\t\t\t\tnavigatedPaths.push(objectPart.name);\n\t\t\t\t\tnavigationProperties.push(objectPart);\n\t\t\t\t\tcurrentEntityType = objectPart.targetType;\n\t\t\t\t\tif (previousEntitySet && previousEntitySet.navigationPropertyBinding.hasOwnProperty(navigatedPaths.join(\"/\"))) {\n\t\t\t\t\t\tcurrentEntitySet = previousEntitySet.navigationPropertyBinding[navigatedPaths.join(\"/\")] as EntitySet;\n\t\t\t\t\t\tpreviousEntitySet = currentEntitySet;\n\t\t\t\t\t\tnavigatedPaths = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentEntitySet = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"EntitySet\":\n\t\t\t\t\tif (rootEntitySet === undefined) {\n\t\t\t\t\t\trootEntitySet = objectPart;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentEntitySet = objectPart;\n\t\t\t\t\tpreviousEntitySet = currentEntitySet;\n\t\t\t\t\tcurrentEntityType = currentEntitySet?.entityType;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n\tconst dataModelPath: DataModelObjectPath<T> = {\n\t\tstartingEntitySet: rootEntitySet as EntitySet,\n\t\ttargetEntityType: currentEntityType as EntityType,\n\t\ttargetEntitySet: currentEntitySet,\n\t\tnavigationProperties: navigationProperties,\n\t\tcontextLocation: undefined,\n\t\ttargetObject: resolvedMetaPath.target,\n\t\tconvertedTypes: convertedTypes\n\t};\n\tdataModelPath.contextLocation = dataModelPath;\n\treturn dataModelPath;\n};\n\n/**\n * Create a ConverterContext object that will be used within the converters.\n * @param {ConvertedMetadata} oConvertedTypes The converted annotation and service types\n * @param {BaseManifestSettings} oManifestSettings The manifestSettings that applies to this page\n * @param {TemplateType} templateType The type of template we're looking at right now\n * @param {IDiagnostics} diagnostics The diagnostics shim\n * @param {Function} mergeFn The function to be used to perfom some deep merges between object\n * @param {DataModelObjectPath} targetDataModelPath The global path to reach the entitySet\n * @returns {ConverterContext} A converter context for the converters\n */\nclass ConverterContext<T = PageContextPathTarget> {\n\tprivate manifestWrapper: ManifestWrapper;\n\n\tprivate baseContextPath: string;\n\n\tconstructor(\n\t\tprivate convertedTypes: ConvertedMetadata,\n\t\tprivate manifestSettings: BaseManifestSettings,\n\t\tprivate diagnostics: IDiagnostics,\n\t\tprivate mergeFn: Function,\n\t\tprivate targetDataModelPath: DataModelObjectPath<T>\n\t) {\n\t\tthis.manifestWrapper = new ManifestWrapper(this.manifestSettings, mergeFn);\n\t\tthis.baseContextPath = getTargetObjectPath(this.targetDataModelPath);\n\t}\n\n\tprivate _getEntityTypeFromFullyQualifiedName(fullyQualifiedName: string): EntityType | undefined {\n\t\treturn this.convertedTypes.entityTypes.find((entityType) => {\n\t\t\tif (fullyQualifiedName.startsWith(entityType.fullyQualifiedName)) {\n\t\t\t\tconst replaceAnnotation = fullyQualifiedName.replace(entityType.fullyQualifiedName, \"\");\n\t\t\t\treturn replaceAnnotation.startsWith(\"/\") || replaceAnnotation.startsWith(\"@\");\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t}\n\n\t/**\n\t * Retrieve the entityType associated with an annotation object.\n\t * @param annotation The annotation object for which we want to find the entityType\n\t * @returns The EntityType the annotation refers to\n\t */\n\tgetAnnotationEntityType<TT extends ServiceObjectAndAnnotation>(\n\t\tannotation?: TT extends ServiceObject ? TT : AnnotationTerm<TT>\n\t): EntityType {\n\t\tif (annotation && typeof annotation === \"object\") {\n\t\t\tconst annotationPath = annotation.fullyQualifiedName;\n\t\t\tconst targetEntityType = this._getEntityTypeFromFullyQualifiedName(annotationPath);\n\t\t\tif (!targetEntityType) {\n\t\t\t\tthrow new Error(`Cannot find Entity Type for ${annotation.fullyQualifiedName}`);\n\t\t\t}\n\t\t\treturn targetEntityType;\n\t\t} else {\n\t\t\treturn this.targetDataModelPath.targetEntityType;\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve the manifest settings defined for a specific control within controlConfiguration.\n\t * @param annotationPath The annotation path or object to evaluate\n\t * @returns The control configuration for that specific annotation path if it exists\n\t */\n\tgetManifestControlConfiguration<TT = ControlManifestConfiguration>(annotationPath: string | AnnotationTerm<unknown>): TT {\n\t\tif (isAnnotationTerm(annotationPath)) {\n\t\t\treturn this.manifestWrapper.getControlConfiguration<TT>(\n\t\t\t\tannotationPath.fullyQualifiedName.replace(this.targetDataModelPath.targetEntityType.fullyQualifiedName, \"\")\n\t\t\t);\n\t\t}\n\t\tconst hasEntitySetKeyInManifest =\n\t\t\ttypeof this.manifestWrapper.getEntitySet() === \"string\" && this.manifestWrapper.getEntitySet()!.length > 0;\n\t\tconst hasContextPathKeyInManifest =\n\t\t\ttypeof this.manifestWrapper.getContextPath() === \"string\" && this.manifestWrapper.getContextPath()!.length > 0;\n\t\tconst isPathAbsolute = annotationPath.startsWith(\"/\");\n\n\t\t// In case of multiple-entitySet, we compare the entity set of the ControlConfiguration with what is specified either in the 'entitySet' or 'contextPath' manifest setting.\n\t\tif (!this.manifestWrapper.hasMultipleEntitySets()) {\n\t\t\treturn this.manifestWrapper.getControlConfiguration(annotationPath);\n\t\t} else if (\n\t\t\t!isPathAbsolute &&\n\t\t\t((hasEntitySetKeyInManifest && this.baseContextPath !== `/${this.manifestWrapper.getEntitySet()}`) ||\n\t\t\t\t(hasContextPathKeyInManifest && this.baseContextPath !== this.manifestWrapper.getContextPath()))\n\t\t) {\n\t\t\treturn this.manifestWrapper.getControlConfiguration<TT>(`${this.baseContextPath}/${annotationPath}`);\n\t\t} else if (Object.keys(this.manifestWrapper.getControlConfiguration(annotationPath)).length > 0) {\n\t\t\treturn this.manifestWrapper.getControlConfiguration(annotationPath);\n\t\t}\n\t\treturn this.manifestWrapper.getControlConfiguration(`${this.baseContextPath}/${annotationPath}`);\n\t}\n\n\t/**\n\t * Create an absolute annotation path based on the current meta model context.\n\t * @param sAnnotationPath The relative annotation path\n\t * @returns The correct annotation path based on the current context\n\t */\n\tgetAbsoluteAnnotationPath(sAnnotationPath: string): string {\n\t\tif (!sAnnotationPath) {\n\t\t\treturn sAnnotationPath;\n\t\t}\n\t\tif (sAnnotationPath[0] === \"/\") {\n\t\t\treturn sAnnotationPath;\n\t\t}\n\t\treturn `${this.baseContextPath}/${sAnnotationPath}`;\n\t}\n\n\t/**\n\t * Retrieve the current entitySet.\n\t * @returns The current EntitySet if it exists.\n\t */\n\tgetEntitySet(): EntitySet | Singleton | undefined {\n\t\treturn this.targetDataModelPath.targetEntitySet as EntitySet | Singleton;\n\t}\n\n\t/**\n\t * Retrieve the context path.\n\t * @returns The context path of the converter.\n\t */\n\tgetContextPath(): string {\n\t\treturn this.baseContextPath;\n\t}\n\n\t/**\n\t * Retrieve the current data model object path.\n\t * @returns The current data model object path\n\t */\n\tgetDataModelObjectPath(): DataModelObjectPath<T> {\n\t\treturn this.targetDataModelPath;\n\t}\n\n\t/**\n\t * Get the EntityContainer.\n\t * @returns The current service EntityContainer\n\t */\n\tgetEntityContainer(): EntityContainer {\n\t\treturn this.convertedTypes.entityContainer;\n\t}\n\n\t/**\n\t * Get the EntityType based on the fully qualified name.\n\t * @returns The current EntityType.\n\t */\n\tgetEntityType(): EntityType {\n\t\treturn this.targetDataModelPath.targetEntityType;\n\t}\n\n\t/**\n\t * Gets the entity type of the parameter in case of a parameterized service.\n\t * @returns The entity type of the parameter\n\t */\n\tgetParameterEntityType(): EntityType {\n\t\tconst parameterEntityType = this.targetDataModelPath.startingEntitySet.entityType;\n\t\tconst isParameterized = !!parameterEntityType.annotations?.Common?.ResultContext;\n\t\treturn (isParameterized && parameterEntityType) as EntityType;\n\t}\n\n\t/**\n\t * Retrieves an annotation from an entity type based on annotation path.\n\t * @param annotationPath The annotation path to be evaluated\n\t * @returns The target annotation path as well as a converter context to go with it\n\t */\n\tgetEntityTypeAnnotation<TT extends ServiceObject | RecordComplexType>(annotationPath: string): ResolvedAnnotationContext<TT> {\n\t\tif (!annotationPath.includes(\"@\")) {\n\t\t\tthrow new Error(`Not an annotation path: '${annotationPath}'`);\n\t\t}\n\n\t\tconst isAbsolute = annotationPath.startsWith(\"/\");\n\t\tlet path: string;\n\n\t\tif (isAbsolute) {\n\t\t\t// path can be used as-is\n\t\t\tpath = annotationPath;\n\t\t} else {\n\t\t\t// build an absolute path based on the entity type (this function works on the type!)\n\t\t\tconst base = this.getContextPath().split(\"@\", 1)[0];\n\t\t\tpath = base.endsWith(\"/\") ? base + annotationPath : `${base}/${annotationPath}`;\n\t\t}\n\n\t\tconst target: ResolutionTarget<AnnotationTerm<TT>> = this.resolveAbsolutePath(path);\n\n\t\tconst dataModelObjectPath = getInvolvedDataModelObjectFromPath<PageContextPathTarget>(\n\t\t\t{ target: target.target as ServiceObject, visitedObjects: target.objectPath },\n\t\t\tthis.convertedTypes,\n\t\t\tisAbsolute ? undefined : this.targetDataModelPath.contextLocation,\n\t\t\ttrue\n\t\t);\n\n\t\treturn {\n\t\t\tannotation: target.target,\n\t\t\tconverterContext: new ConverterContext(\n\t\t\t\tthis.convertedTypes,\n\t\t\t\tthis.manifestSettings,\n\t\t\t\tthis.diagnostics,\n\t\t\t\tthis.mergeFn,\n\t\t\t\tdataModelObjectPath\n\t\t\t)\n\t\t};\n\t}\n\n\t/**\n\t * Retrieve the type of template we're working on (e.g. ListReport / ObjectPage / ...).\n\t * @returns The current tenplate type\n\t */\n\tgetTemplateType(): TemplateType {\n\t\treturn this.manifestWrapper.getTemplateType();\n\t}\n\n\t/**\n\t * Retrieve the converted types.\n\t * @returns The current converted types\n\t */\n\tgetConvertedTypes(): ConvertedMetadata {\n\t\treturn this.convertedTypes;\n\t}\n\n\t/**\n\t * Retrieve a relative annotation path between an annotation path and an entity type.\n\t * @param annotationPath\n\t * @param entityType\n\t * @returns The relative anntotation path.\n\t */\n\tgetRelativeAnnotationPath(annotationPath: string, entityType: EntityType): string {\n\t\treturn annotationPath.replace(entityType.fullyQualifiedName, \"\");\n\t}\n\n\t/**\n\t * Transform an entityType based path to an entitySet based one (ui5 templating generally expect an entitySetBasedPath).\n\t * @param annotationPath\n\t * @returns The EntitySet based annotation path\n\t */\n\tgetEntitySetBasedAnnotationPath(annotationPath: string): string {\n\t\tif (!annotationPath) {\n\t\t\treturn annotationPath;\n\t\t}\n\t\tconst entityTypeFQN = this.targetDataModelPath.targetEntityType.fullyQualifiedName;\n\t\tif (\n\t\t\tthis.targetDataModelPath.targetEntitySet ||\n\t\t\t((this.baseContextPath.startsWith(\"/\") && this.baseContextPath.match(/\\//g)) || []).length > 1\n\t\t) {\n\t\t\tlet replacedAnnotationPath = annotationPath.replace(entityTypeFQN, \"/\");\n\t\t\tif (replacedAnnotationPath.length > 2 && replacedAnnotationPath[0] === \"/\" && replacedAnnotationPath[1] === \"/\") {\n\t\t\t\treplacedAnnotationPath = replacedAnnotationPath.substring(1);\n\t\t\t}\n\t\t\treturn this.baseContextPath + (replacedAnnotationPath.startsWith(\"/\") ? replacedAnnotationPath : `/${replacedAnnotationPath}`);\n\t\t} else {\n\t\t\treturn `/${annotationPath}`;\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve the manifest wrapper for the current context.\n\t * @returns The current manifest wrapper\n\t */\n\tgetManifestWrapper(): ManifestWrapper {\n\t\treturn this.manifestWrapper;\n\t}\n\n\tgetDiagnostics(): IDiagnostics {\n\t\treturn this.diagnostics;\n\t}\n\n\t/**\n\t * Retrieve the target from an absolute path.\n\t * @param path The path we want to get the target\n\t * @returns The absolute path\n\t */\n\tresolveAbsolutePath<TT>(path: string): ResolutionTarget<TT> {\n\t\treturn this.convertedTypes.resolvePath(path);\n\t}\n\n\t/**\n\t * Retrieve a new converter context, scoped for a different context path.\n\t * @param contextPath The path we want to orchestrate the converter context around\n\t * @returns The converted context for the sub path\n\t */\n\tgetConverterContextFor<K>(contextPath: string): ConverterContext<K> {\n\t\tconst resolvedMetaPath: ResolutionTarget<K> = this.convertedTypes.resolvePath<K>(contextPath);\n\t\tconst targetPath = getDataModelPathForEntitySet(resolvedMetaPath, this.convertedTypes);\n\t\treturn new ConverterContext<K>(this.convertedTypes, this.manifestSettings, this.diagnostics, this.mergeFn, targetPath);\n\t}\n\n\t/**\n\t * Get all annotations of a given term and vocabulary on an entity type\n\t * (or on the current entity type if entityType isn't specified).\n\t * @param vocabularyName\n\t * @param annotationTerm\n\t * @param [annotationSources]\n\t * @returns All the annotation for a specific term and vocabulary from an entity type\n\t */\n\tgetAnnotationsByTerm<TT>(\n\t\tvocabularyName: keyof EntityTypeAnnotations,\n\t\tannotationTerm: string,\n\t\tannotationSources: (ServiceObject | undefined)[] = [this.getEntityType()]\n\t): AnnotationTerm<TT>[] {\n\t\tlet outAnnotations: AnnotationTerm<TT>[] = [];\n\t\tannotationSources.forEach((annotationSource) => {\n\t\t\tif (annotationSource) {\n\t\t\t\tconst annotations: Record<string, AnnotationTerm<TT> & { term: string }> =\n\t\t\t\t\tannotationSource?.annotations[vocabularyName] || {};\n\t\t\t\tif (annotations) {\n\t\t\t\t\toutAnnotations = Object.keys(annotations)\n\t\t\t\t\t\t.filter((annotation) => annotations[annotation].term === annotationTerm)\n\t\t\t\t\t\t.reduce((previousValue: AnnotationTerm<TT>[], key: string) => {\n\t\t\t\t\t\t\tpreviousValue.push(annotations[key]);\n\t\t\t\t\t\t\treturn previousValue;\n\t\t\t\t\t\t}, outAnnotations);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn outAnnotations;\n\t}\n\n\t/**\n\t * Retrieves the relative model path based on the current context path.\n\t * @returns The relative model path or undefined if the path is not resolveable\n\t */\n\tgetRelativeModelPathFunction(): Function {\n\t\tconst targetDataModelPath = this.targetDataModelPath;\n\t\tconst convertedMetaModel = this.convertedTypes;\n\t\treturn function (sPath: string) {\n\t\t\tconst singletonPath = singletonPathVisitor(sPath, convertedMetaModel, []);\n\t\t\tconst enhancedPath = enhanceDataModelPath(targetDataModelPath, sPath);\n\t\t\tconst contextRelativePath = getContextRelativeTargetObjectPath(enhancedPath, true);\n\t\t\tif (contextRelativePath) {\n\t\t\t\treturn contextRelativePath;\n\t\t\t}\n\t\t\treturn singletonPath;\n\t\t};\n\t}\n\n\t/**\n\t * Create the converter context necessary for a macro based on a metamodel context.\n\t * @param entityName\n\t * @param oMetaModelContext\n\t * @param diagnostics\n\t * @param mergeFn\n\t * @param targetDataModelPath\n\t * @param manifestSettings\n\t * @returns The current converter context\n\t */\n\tstatic createConverterContextForMacro(\n\t\tentityName: string,\n\t\toMetaModelContext: Context | ODataMetaModel,\n\t\tdiagnostics: IDiagnostics,\n\t\tmergeFn: Function,\n\t\ttargetDataModelPath?: DataModelObjectPath<PageContextPathTarget>,\n\t\tmanifestSettings: BaseManifestSettings = {} as BaseManifestSettings\n\t): ConverterContext<PageContextPathTarget> {\n\t\tconst oMetaModel: ODataMetaModel = oMetaModelContext.isA(\"sap.ui.model.odata.v4.ODataMetaModel\")\n\t\t\t? (oMetaModelContext as ODataMetaModel)\n\t\t\t: ((oMetaModelContext as Context).getModel() as unknown as ODataMetaModel);\n\t\tconst oConvertedMetadata = convertTypes(oMetaModel);\n\t\tlet targetEntitySet: Singleton | EntitySet = oConvertedMetadata.entitySets.find(\n\t\t\t(entitySet) => entitySet.name === entityName\n\t\t) as EntitySet;\n\t\tif (!targetEntitySet) {\n\t\t\ttargetEntitySet = oConvertedMetadata.singletons.find((entitySet) => entitySet.name === entityName) as Singleton;\n\t\t}\n\t\tif (!targetDataModelPath || targetEntitySet !== targetDataModelPath.startingEntitySet) {\n\t\t\ttargetDataModelPath = {\n\t\t\t\tstartingEntitySet: targetEntitySet,\n\t\t\t\tnavigationProperties: [],\n\t\t\t\ttargetEntitySet: targetEntitySet,\n\t\t\t\t// contained entity does not have an entity set but only entity type\n\t\t\t\ttargetEntityType:\n\t\t\t\t\ttargetEntitySet?.entityType || oConvertedMetadata.entityTypes.find((entityType) => entityType.name === entityName),\n\t\t\t\ttargetObject: targetEntitySet as EntitySet,\n\t\t\t\tconvertedTypes: oConvertedMetadata\n\t\t\t};\n\t\t}\n\t\treturn new ConverterContext(oConvertedMetadata, manifestSettings, diagnostics, mergeFn, targetDataModelPath);\n\t}\n\n\t/**\n\t * Resolves a metadata binding to its text.\n\t * @param path\n\t * @returns The resolved text if possible, else the input value or an empty string if the path was undefined\n\t */\n\tfetchTextFromMetaModel(path: string | undefined): string {\n\t\treturn ModelHelper.fetchTextFromMetaModel(path, this);\n\t}\n}\n\nexport default ConverterContext;\n"],"mappings":"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","ignoreList":[]}