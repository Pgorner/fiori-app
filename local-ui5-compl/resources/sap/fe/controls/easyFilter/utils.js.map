{"version":3,"file":"utils.js","names":["resourceBundle","Lib","getResourceBundleFor","dateTimeOffset","DateTimeOffset","areItemsSame","arr1","arr2","length","i","operator","selectedValues","every","value","index","areArraySame","async","areCodeListsSame","arrNew1","getCodeListArray","arrNew2","descriptionNew1","map","data","description","descriptionNew2","value1","value2","arr","convertDateToString","tokenType","isDateTimeOffset","formattedDateTime","formatValue","DateFormat","getDateInstance","format","getTimeInstance","mapOperator","newValue","convertBoolToString","Date","FilterOperator","GT","LT","GE","LE","EQ","Contains","EndsWith","StartsWith","NE","NotContains","NotEndsWith","NotStartsWith","toString","mapOperatorForBetweenOperator","values","newValue1","newValue2","BT","isBetweenSelectedValues","NB","getText","formatData","tokens","filterValues","filterBarMetadata","visitedMapForMandatoryTokens","filterValue","filterCriteria","find","field","name","type","tokenIndex","findIndex","token","key","keySpecificSelectedValues","EasyFilterUtils","newToken","label","push","currentToken","isRequired"],"sources":["./utils.ts"],"sourcesContent":["import type { PrimitiveType } from \"@sap-ux/vocabularies-types/Edm\";\nimport Lib from \"sap/ui/core/Lib\";\nimport DateFormat from \"sap/ui/core/format/DateFormat\";\nimport FilterOperator from \"sap/ui/model/FilterOperator\";\nimport DateTimeOffset from \"sap/ui/model/odata/type/DateTimeOffset\";\nimport type { EasyFilterResult, PropertyMetadata } from \"ux/eng/fioriai/reuse/easyfilter/EasyFilter\";\nimport type {\n\tBetweenSelectedValues,\n\tEasyFilterPropertyMetadata,\n\tTokenDefinition,\n\tTokenSelectedValuesDefinition,\n\tTokenType\n} from \"./EasyFilterBarContainer\";\n\ntype codeListType = PropertyMetadata[\"codeList\"];\ntype finalCodeListType = { value: PrimitiveType; description: string }[];\nconst resourceBundle = Lib.getResourceBundleFor(\"sap.fe.controls\")!;\nconst dateTimeOffset = new DateTimeOffset();\n\nfunction areItemsSame(arr1: readonly TokenSelectedValuesDefinition[], arr2: readonly TokenSelectedValuesDefinition[]): boolean {\n\tif (arr1.length !== arr2.length) {\n\t\treturn false;\n\t}\n\t// Compare elements of both arrays\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (\n\t\t\tarr1[i].operator !== arr2[i].operator ||\n\t\t\t!arr1[i].selectedValues.every((value, index) => value === arr2[i].selectedValues[index])\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true; // Arrays are the same\n}\n\nfunction areArraySame(arr1: readonly unknown[], arr2: readonly unknown[]): boolean {\n\tif (arr1.length !== arr2.length) {\n\t\treturn false;\n\t}\n\t// Compare elements of both arrays\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (arr1[i] !== arr2[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true; // Arrays are the same\n}\n\nasync function areCodeListsSame(arr1: codeListType, arr2: codeListType): Promise<boolean> {\n\tconst arrNew1: finalCodeListType | undefined = await getCodeListArray(arr1);\n\tconst arrNew2: finalCodeListType | undefined = await getCodeListArray(arr2);\n\tconst descriptionNew1 = arrNew1?.map((data) => data.description);\n\tconst descriptionNew2 = arrNew2?.map((data) => data.description);\n\n\tconst value1 = arrNew1?.map((data) => data.value);\n\tconst value2 = arrNew2?.map((data) => data.value);\n\tif (!descriptionNew1 || !descriptionNew2) {\n\t\treturn false;\n\t}\n\treturn areArraySame(descriptionNew1, descriptionNew2) && areArraySame(value1 as PrimitiveType, value2 as PrimitiveType);\n}\n\nasync function getCodeListArray(arr: codeListType): Promise<finalCodeListType | undefined> {\n\tif (typeof arr === \"function\") {\n\t\treturn arr();\n\t}\n\treturn arr;\n}\n\nfunction convertDateToString(value: Date, tokenType: TokenType, isDateTimeOffset: boolean): string {\n\tlet formattedDateTime = \"\";\n\tif (isDateTimeOffset) {\n\t\treturn dateTimeOffset.formatValue(value, \"string\") as string;\n\t}\n\tswitch (tokenType) {\n\t\tcase \"Calendar\":\n\t\t\tformattedDateTime = DateFormat.getDateInstance().format(value);\n\t\t\tbreak;\n\t\tcase \"Time\":\n\t\t\tformattedDateTime = DateFormat.getTimeInstance().format(value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn formattedDateTime;\n}\n\n/**\n * Create a string representation of the operator and value.\n * @param operator The operator to represent\n * @param value The value to represent\n * @param tokenType The token's type\n * @param isDateTimeOffset Checks if the data type is of DateTimeOffset\n * @returns The string representation of the operator and value\n */\nfunction mapOperator(\n\toperator: FilterOperator,\n\tvalue: string | number | boolean | Date,\n\ttokenType: TokenType,\n\tisDateTimeOffset: boolean\n): string {\n\tlet newValue: number | string = \"\";\n\tif (typeof value === \"boolean\") {\n\t\tnewValue = convertBoolToString(value);\n\t} else if (value instanceof Date) {\n\t\tnewValue = convertDateToString(value, tokenType, isDateTimeOffset);\n\t} else {\n\t\tnewValue = value;\n\t}\n\n\tswitch (operator) {\n\t\tcase FilterOperator.GT:\n\t\t\treturn `> ${newValue}`;\n\t\tcase FilterOperator.LT:\n\t\t\treturn `< ${newValue}`;\n\t\tcase FilterOperator.GE:\n\t\t\treturn `>= ${newValue}`;\n\t\tcase FilterOperator.LE:\n\t\t\treturn `<= ${newValue}`;\n\t\tcase FilterOperator.EQ:\n\t\t\treturn `${newValue}`;\n\t\tcase FilterOperator.Contains:\n\t\t\treturn `*${newValue}*`;\n\t\tcase FilterOperator.EndsWith:\n\t\t\treturn `*${newValue}`;\n\t\tcase FilterOperator.StartsWith:\n\t\t\treturn `${newValue}*`;\n\t\tcase FilterOperator.NE:\n\t\t\treturn `!=(${newValue})`;\n\t\tcase FilterOperator.NotContains:\n\t\t\treturn `!(*${newValue}*)`;\n\t\tcase FilterOperator.NotEndsWith:\n\t\t\treturn `!(*${newValue})`;\n\t\tcase FilterOperator.NotStartsWith:\n\t\t\treturn `!(${newValue}*)`;\n\t\tdefault:\n\t\t\treturn newValue?.toString();\n\t}\n}\n\nfunction mapOperatorForBetweenOperator(\n\toperator: FilterOperator,\n\tvalues: BetweenSelectedValues,\n\ttokenType: TokenType,\n\tisDateTimeOffset: boolean\n): string {\n\tlet newValue1: string | number | Date = \"\";\n\tlet newValue2: string | number | Date = \"\";\n\tif (typeof values[0] === \"boolean\") {\n\t\tnewValue1 = convertBoolToString(values[0]);\n\t} else if (values[0] instanceof Date) {\n\t\tnewValue1 = convertDateToString(values[0], tokenType, isDateTimeOffset);\n\t} else {\n\t\tnewValue1 = values[0];\n\t}\n\n\tif (typeof values[1] === \"boolean\") {\n\t\tnewValue2 = convertBoolToString(values[1]);\n\t} else if (values[1] instanceof Date) {\n\t\tnewValue2 = convertDateToString(values[1], tokenType, isDateTimeOffset);\n\t} else {\n\t\tnewValue2 = values[1];\n\t}\n\tif (operator === FilterOperator.BT) {\n\t\treturn `${newValue1}...${newValue2}`;\n\t} else {\n\t\treturn `!(${newValue1}...${newValue2})`;\n\t}\n}\n\nfunction isBetweenSelectedValues(operator: FilterOperator): boolean {\n\treturn operator === FilterOperator.BT || operator === FilterOperator.NB;\n}\n\nfunction convertBoolToString(value: boolean): string {\n\treturn value\n\t\t? resourceBundle.getText(\"M_EASY_FILTER_SELECTED_VALUES_TRUE\")\n\t\t: resourceBundle.getText(\"M_EASY_FILTER_SELECTED_VALUES_FALSE\");\n}\n\nfunction formatData(\n\ttokens: TokenDefinition[],\n\tfilterValues: EasyFilterResult[\"filter\"],\n\tfilterBarMetadata: EasyFilterPropertyMetadata[]\n): void {\n\tif (filterValues) {\n\t\tconst visitedMapForMandatoryTokens: Record<string, boolean> = {};\n\t\tfor (const filterValue of filterValues) {\n\t\t\tconst filterCriteria = filterBarMetadata.find((field) => field.name === filterValue.name);\n\t\t\tif (filterCriteria) {\n\t\t\t\tconst { type } = filterCriteria;\n\t\t\t\tconst tokenIndex = tokens.findIndex((token) => token.key === filterValue.name);\n\t\t\t\tconst { operator, values } = filterValue;\n\t\t\t\tlet keySpecificSelectedValues: TokenSelectedValuesDefinition;\n\t\t\t\tif (EasyFilterUtils.isBetweenSelectedValues(operator)) {\n\t\t\t\t\tkeySpecificSelectedValues = {\n\t\t\t\t\t\toperator,\n\t\t\t\t\t\tselectedValues: values as BetweenSelectedValues\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tkeySpecificSelectedValues = {\n\t\t\t\t\t\toperator: operator as Exclude<FilterOperator, FilterOperator.BT | FilterOperator.NB>,\n\t\t\t\t\t\tselectedValues: values as string[] | Date[] | number[] | boolean[]\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (tokenIndex === -1) {\n\t\t\t\t\t// Add new token if it doesn't exist\n\t\t\t\t\tconst newToken: TokenDefinition = {\n\t\t\t\t\t\tkey: filterValue.name,\n\t\t\t\t\t\tlabel: filterCriteria.label as string,\n\t\t\t\t\t\tkeySpecificSelectedValues: [keySpecificSelectedValues],\n\t\t\t\t\t\ttype\n\t\t\t\t\t};\n\t\t\t\t\ttokens.push(newToken);\n\t\t\t\t} else {\n\t\t\t\t\t// Update existing token\n\t\t\t\t\tconst currentToken = tokens[tokenIndex];\n\t\t\t\t\t//If its default value , override it\n\t\t\t\t\tif ((currentToken.isRequired ?? false) && !visitedMapForMandatoryTokens[currentToken.key]) {\n\t\t\t\t\t\tcurrentToken.keySpecificSelectedValues = [keySpecificSelectedValues];\n\t\t\t\t\t\tvisitedMapForMandatoryTokens[currentToken.key] = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentToken.keySpecificSelectedValues.push(keySpecificSelectedValues);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst EasyFilterUtils = {\n\tareItemsSame,\n\tareCodeListsSame,\n\tgetCodeListArray,\n\tareArraySame,\n\tmapOperator,\n\tmapOperatorForBetweenOperator,\n\tisBetweenSelectedValues,\n\tformatData\n};\n\nexport default EasyFilterUtils;\n"],"mappings":"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","ignoreList":[]}