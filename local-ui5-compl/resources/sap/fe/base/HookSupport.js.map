{"version":3,"file":"HookSupport.js","names":["registeredInstances","registeredHandlers","hookable","execution","target","propertyKey","descriptor","indexableTarget","toString","fn","cExTInstanceHookMap","this","hookedHandlers","push","handlers","index","indexOf","splice","oldValue","value","async","returnValue","bind","arguments","handler","_exports","isAlreadyRegistered","existingRegistrations","newRegistration","find","r","name","method","targetMethod","controllerExtensionHandler","String","constructor","initControllerExtensionHookHandlers","controller","indexableController","registeredHandler","handlerFunction","getView","attachBeforeExit","xmlViewPreprocessor","source","_caller","_settings","sourceView","getController","macroAPIChild","findAggregatedObjects","s","isA","managedObject"],"sources":["./HookSupport.ts"],"sourcesContent":["import type { ExtensionOverrideExecution } from \"sap/fe/base/ClassSupport\";\nimport type Controller from \"sap/ui/core/mvc/Controller\";\nimport type XMLView from \"sap/ui/core/mvc/XMLView\";\n\n/**\n * This type is to be extended with all controller extensions and methods that are hookable.\n */\ntype HookableControllerExtensions = {\n\teditFlow: {\n\t\tonAfterSave: true;\n\t\tonBeforeSave: true;\n\t};\n\tcollaborationManager: {\n\t\tcollectAvailableCards: true;\n\t};\n\tpaginator: {\n\t\tinitialize: true;\n\t};\n\trouting: {\n\t\tonAfterBinding: true;\n\t};\n};\n\ntype HandlerConfiguration<CExtName extends keyof HookableControllerExtensions> = {\n\tname: CExtName;\n\tmethod: keyof HookableControllerExtensions[CExtName];\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype HandlerRegistration = HandlerConfiguration<any> & { targetMethod: string };\n\ntype FunctionMap = {\n\t[key: string]: Function;\n};\ntype DeepFunctionMap = {\n\t[key: string]: FunctionMap;\n};\ntype HookMap = {\n\thookedHandlers: {\n\t\t[key: string]: Function[];\n\t};\n};\n\n// Use two arrays as we cannot index a map through an arbitrary object instance\nconst registeredInstances: Function[] = [];\nconst registeredHandlers: HandlerRegistration[][] = [];\n\n/**\n * Marks a controller extension method to be hookable by generating additional methods that can be used to attach and detach handlers at runtime.\n * @param execution\n * @returns A method decorator\n */\nexport function hookable(execution: ExtensionOverrideExecution): MethodDecorator {\n\treturn function (target: unknown, propertyKey: string | symbol, descriptor: PropertyDescriptor) {\n\t\tconst indexableTarget = target as FunctionMap;\n\n\t\tindexableTarget[`attach${propertyKey.toString()}`] = function (fn: Function): void {\n\t\t\tconst cExTInstanceHookMap = this as unknown as HookMap;\n\t\t\tif (!cExTInstanceHookMap.hookedHandlers) {\n\t\t\t\tcExTInstanceHookMap.hookedHandlers = {};\n\t\t\t}\n\t\t\tif (!cExTInstanceHookMap.hookedHandlers[propertyKey.toString()]) {\n\t\t\t\tcExTInstanceHookMap.hookedHandlers[propertyKey.toString()] = [];\n\t\t\t}\n\t\t\tcExTInstanceHookMap.hookedHandlers[propertyKey.toString()].push(fn);\n\t\t};\n\t\tindexableTarget[`detach${propertyKey.toString()}`] = function (fn: Function): void {\n\t\t\tconst cExTInstanceHookMap = this as unknown as HookMap;\n\t\t\tconst handlers = cExTInstanceHookMap.hookedHandlers[propertyKey.toString()];\n\t\t\tconst index = handlers.indexOf(fn);\n\t\t\tif (index !== -1) {\n\t\t\t\thandlers.splice(index, 1);\n\t\t\t}\n\t\t};\n\n\t\tconst oldValue = descriptor.value;\n\t\tif (execution === \"BeforeAsync\" || execution === \"AfterAsync\") {\n\t\t\tdescriptor.value = async function (...args: unknown[]): Promise<unknown> {\n\t\t\t\tconst cExTInstanceHookMap = this as unknown as HookMap;\n\t\t\t\tconst handlers = (cExTInstanceHookMap?.hookedHandlers && cExTInstanceHookMap?.hookedHandlers[propertyKey.toString()]) || [];\n\t\t\t\tlet returnValue: unknown;\n\t\t\t\tif (execution === \"AfterAsync\") {\n\t\t\t\t\treturnValue = await oldValue.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\tfor (const handler of handlers) {\n\t\t\t\t\tawait handler.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\tif (execution === \"BeforeAsync\") {\n\t\t\t\t\treturnValue = await oldValue.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\treturn returnValue;\n\t\t\t};\n\t\t} else {\n\t\t\tdescriptor.value = function (...args: unknown[]): unknown {\n\t\t\t\tconst cExTInstanceHookMap = this as unknown as HookMap;\n\t\t\t\tconst handlers = (cExTInstanceHookMap?.hookedHandlers && cExTInstanceHookMap?.hookedHandlers[propertyKey.toString()]) || [];\n\t\t\t\tlet returnValue: unknown;\n\t\t\t\tif (execution === \"After\") {\n\t\t\t\t\treturnValue = oldValue.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\tfor (const handler of handlers) {\n\t\t\t\t\thandler.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\tif (execution === \"Before\") {\n\t\t\t\t\treturnValue = oldValue.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\treturn returnValue;\n\t\t\t};\n\t\t}\n\t};\n}\n\n/**\n * Checks whether a newRegistration is already included in some existingRegistrations by comparing all relevant attributes.\n * @param existingRegistrations\n * @param newRegistration\n * @returns Result of the check\n */\nfunction isAlreadyRegistered(existingRegistrations: HandlerRegistration[], newRegistration: HandlerRegistration): boolean {\n\treturn !!existingRegistrations.find(\n\t\t(r) => r.name === newRegistration.name && r.method === newRegistration.method && r.targetMethod === newRegistration.targetMethod\n\t);\n}\n\n/**\n * Registers a method as controller extension hook handler.\n *\n * Currently, only methods of runtime building blocks are supported.\n * @param name Controller extension to hook into\n * @param method Method to hook into\n * @returns A method decorator\n */\nexport function controllerExtensionHandler<CExtName extends keyof HookableControllerExtensions>(\n\tname: CExtName,\n\tmethod: keyof HookableControllerExtensions[CExtName]\n): MethodDecorator {\n\treturn function (target: { constructor: Function }, propertyKey: string) {\n\t\tconst newRegistration = { name, method: String(method), targetMethod: propertyKey };\n\t\tconst index = registeredInstances.indexOf(target.constructor);\n\n\t\t// We need to check if this exact handler is already registered as handlers are registered statically (on the constructor)\n\t\tif (index !== -1 && !isAlreadyRegistered(registeredHandlers[index], newRegistration)) {\n\t\t\tregisteredHandlers[index].push(newRegistration);\n\t\t} else {\n\t\t\tregisteredInstances.push(target.constructor);\n\t\t\tregisteredHandlers.push([newRegistration]);\n\t\t}\n\t} as MethodDecorator;\n}\n\n/**\n * Initializes all controller extension handlers registered for a given target.\n * @param target Target class to initialize the handlers for\n * @param target.constructor\n * @param controller PageController instance to get the controller extensions instances from\n */\nexport function initControllerExtensionHookHandlers(target: { constructor: Function }, controller: Controller): void {\n\tconst index = registeredInstances.indexOf(target.constructor);\n\tif (index !== -1) {\n\t\tconst indexableController = controller as unknown as DeepFunctionMap;\n\t\tconst indexableTarget = target as unknown as FunctionMap;\n\n\t\tfor (const registeredHandler of registeredHandlers[index]) {\n\t\t\tconst handlerFunction = indexableTarget[registeredHandler.targetMethod].bind(target);\n\n\t\t\tindexableController[registeredHandler.name][`attach${String(registeredHandler.method)}`](handlerFunction);\n\t\t\tcontroller.getView()?.attachBeforeExit(() => {\n\t\t\t\tindexableController[registeredHandler.name][`detach${String(registeredHandler.method)}`](handlerFunction);\n\t\t\t});\n\t\t}\n\t}\n}\n\nexport function xmlViewPreprocessor(source: object, _caller?: unknown, _settings?: object): void {\n\tconst sourceView = source as XMLView;\n\tconst controller = sourceView.getController() as Controller | undefined;\n\tif (controller) {\n\t\tconst macroAPIChild = sourceView.findAggregatedObjects(true, (s) => s.isA(\"sap.fe.macros.MacroAPI\"));\n\t\tfor (const managedObject of macroAPIChild) {\n\t\t\tinitControllerExtensionHookHandlers(managedObject, controller);\n\t\t}\n\t}\n}\n"],"mappings":"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","ignoreList":[]}