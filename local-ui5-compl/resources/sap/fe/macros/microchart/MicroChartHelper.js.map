{"version":3,"file":"MicroChartHelper.js","names":["calendarPatternMap","yyyy","Q","MM","ww","yyyyMMdd","yyyyMM","MicroChartHelper","getThresholdColor","value","iContext","path","context","getPath","includes","ValueColor","Error","Critical","Neutral","getMeasurePropertyPaths","chartAnnotations","entityTypeAnnotations","chartType","propertyPath","Log","warning","undefined","measureIndex","Measures","iMeasureAttribute","CommonHelper","getMeasureAttributeIndex","measureAttribute","MeasureAttributes","dataPoint","DataPoint","$AnnotationPath","Value","$Path","push","join","getHiddenPathExpression","_len","arguments","length","args","Array","_key","hiddenPaths","forEach","call","hiddenProperty","isNotAlwaysHidden","maxValue","valueHidden","maxValueHidden","this","logError","error","formatDecimal","property","fractionDigits","constraints","formatOptions","scale","$Scale","$Nullable","$Precision","decimals","NumberFormat","getFloatInstance","style","preserveDecimals","format","getSelectParameters","groupId","sortOrder","criticalityCalculation","criticality","otherPaths","sorters","parameters","sorter","Property","Descending","cricticalityCalculationKeys","Object","keys","key","getDataPointQualifiersForMeasures","qualifiers","measureAttributes","fnAddDataPointQualifier","chartMeasure","measure","$PropertyPath","qualifier","Measure","annotationPath","split","logWarning","getDisplayValueForMicroChart","pathText","valueTextPath","valueDataPointPath","valueFormat","ValueFormat","NumberOfFractionalDigits","shouldMicroChartRender","dataPointValueHidden","targetAnnotations","dataPointMaxValue","availableChartTypes","dataPointValue","hiddenPath","chartAnnotationDimension","Dimensions","finalDataPointValue","dataPointMaximumValue","MaximumValue","maxValueHiddenPath","getDataPointQualifiersForMicroChart","getColorPaletteForMicroChart","Criticality","getMeasureScaleForMicroChart","valueOf","getBindingExpressionForMicrochart","microChart","collection","uiName","condition","currencyOrUnit","getUOMPathForMicrochart","showOnlyChart","dataPointCriticallity","targetObject","functionValue","batchGroupId","annotations","ISOCurrency","Unit","getAggregationForMicrochart","aggregationType","dimension","measureOrDimensionBar","dataPointCriticallityCalc","targetValuePath","dimensionPropertyPath","$target","Common","Text","CriticalityCalculation","TargetValue","getCurrencyOrUnit","getCalendarPattern","propertyType","formatDimension","date","pattern","DateFormat","getDateInstance","parse","Date","getTime","formatStringDimension","matchedValue","toString","match","getX","some","type"],"sources":["./MicroChartHelper.ts"],"sourcesContent":["import type { PathAnnotationExpression, PropertyPath } from \"@sap-ux/vocabularies-types/Edm\";\nimport type { Measure } from \"@sap-ux/vocabularies-types/vocabularies/Analytics\";\nimport type { SortOrderType } from \"@sap-ux/vocabularies-types/vocabularies/Common\";\nimport { CommonAnnotationTerms } from \"@sap-ux/vocabularies-types/vocabularies/Common\";\nimport { MeasuresAnnotationTerms } from \"@sap-ux/vocabularies-types/vocabularies/Measures\";\nimport type { PropertyAnnotations_Measures } from \"@sap-ux/vocabularies-types/vocabularies/Measures_Edm\";\nimport type {\n\tChart,\n\tChartMeasureAttributeTypeTypes,\n\tCriticalityCalculationType,\n\tDataPointType\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTerms } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport Log from \"sap/base/Log\";\nimport type { MetaModelEntityTypeAnnotations, MetaModelPropertyAnnotations } from \"sap/fe/core/converters/MetaModelConverter\";\nimport type { DataModelObjectPath } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport type { ComputedAnnotationInterface } from \"sap/fe/core/templating/UIFormatters\";\nimport CommonHelper from \"sap/fe/macros/CommonHelper\";\nimport type MicroChartBlock from \"sap/fe/macros/microchart/MicroChart.block\";\nimport { ValueColor } from \"sap/m/library\";\nimport DateFormat from \"sap/ui/core/format/DateFormat\";\nimport NumberFormat from \"sap/ui/core/format/NumberFormat\";\nimport type { MetaModelNavProperty, MetaModelType } from \"types/metamodel_types\";\n\ntype Property = {\n\t$kind?: string;\n\t$Type?: string;\n\t$Name?: string;\n\t$Nullable?: boolean;\n\t$MaxLength?: number;\n\t$Precision?: number;\n\t$Scale?: number | string;\n};\n\nconst calendarPatternMap: { [key: string]: RegExp } = {\n\tyyyy: /[1-9][0-9]{3,}|0[0-9]{3}/,\n\tQ: /[1-4]/,\n\tMM: /0[1-9]|1[0-2]/,\n\tww: /0[1-9]|[1-4][0-9]|5[0-3]/,\n\tyyyyMMdd: /([1-9][0-9]{3,}|0[0-9]{3})(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])/,\n\tyyyyMM: /([1-9][0-9]{3,}|0[0-9]{3})(0[1-9]|1[0-2])/,\n\t\"yyyy-MM-dd\": /([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])/\n};\n\n/**\n * Helper class used by MDC_Controls to handle SAP Fiori elements for OData V4\n * @private\n * @experimental This module is only for internal/experimental use!\n */\nconst MicroChartHelper = {\n\t/**\n\t * This function returns the Threshold Color for bullet micro chart.\n\t * @param value Threshold value provided in the annotations\n\t * @param iContext InterfaceContext with path to the threshold\n\t * @returns The indicator for Threshold Color\n\t */\n\tgetThresholdColor: function (value: string, iContext: ComputedAnnotationInterface): ValueColor {\n\t\tconst path = iContext.context.getPath();\n\t\tif (path.includes(\"DeviationRange\")) {\n\t\t\treturn ValueColor.Error;\n\t\t} else if (path.includes(\"ToleranceRange\")) {\n\t\t\treturn ValueColor.Critical;\n\t\t}\n\t\treturn ValueColor.Neutral;\n\t},\n\n\t/**\n\t * To fetch measures from DataPoints.\n\t * @param chartAnnotations Chart Annotations\n\t * @param entityTypeAnnotations EntityType Annotations\n\t * @param chartType Chart Type used\n\t * @returns Containing all measures.\n\t * @private\n\t */\n\tgetMeasurePropertyPaths: function (\n\t\tchartAnnotations: MetaModelType<Chart>,\n\t\tentityTypeAnnotations: MetaModelEntityTypeAnnotations | undefined,\n\t\tchartType: string\n\t): string | undefined {\n\t\tconst propertyPath: string[] = [];\n\n\t\tif (!entityTypeAnnotations) {\n\t\t\tLog.warning(\"FE:Macro:MicroChart : Couldn't find annotations for the DataPoint.\");\n\t\t\treturn undefined;\n\t\t}\n\n\t\tfor (const measureIndex in chartAnnotations.Measures) {\n\t\t\tconst iMeasureAttribute = CommonHelper.getMeasureAttributeIndex(measureIndex as unknown as number, chartAnnotations),\n\t\t\t\tmeasureAttribute =\n\t\t\t\t\tiMeasureAttribute > -1 && chartAnnotations.MeasureAttributes && chartAnnotations.MeasureAttributes[iMeasureAttribute],\n\t\t\t\tdataPoint = (measureAttribute &&\n\t\t\t\t\tentityTypeAnnotations &&\n\t\t\t\t\tentityTypeAnnotations[measureAttribute.DataPoint?.$AnnotationPath as keyof MetaModelEntityTypeAnnotations]) as\n\t\t\t\t\t| MetaModelType<DataPointType>\n\t\t\t\t\t| undefined;\n\t\t\tif (dataPoint?.Value?.$Path) {\n\t\t\t\tpropertyPath.push(dataPoint.Value.$Path);\n\t\t\t} else {\n\t\t\t\tLog.warning(\n\t\t\t\t\t`FE:Macro:MicroChart : Couldn't find DataPoint(Value) measure for the measureAttribute ${chartType} MicroChart.`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn propertyPath.join(\",\");\n\t},\n\n\t/**\n\t * This function returns the visible expression path.\n\t * @param args\n\t * @returns Expression Binding for the visible.\n\t */\n\tgetHiddenPathExpression: function (...args: unknown[]): string | boolean {\n\t\tif (!args[0] && !args[1]) {\n\t\t\treturn true;\n\t\t}\n\t\tif (args[0] === true || args[1] === true) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst hiddenPaths: string[] = [];\n\t\t[].forEach.call(args, function (hiddenProperty: unknown) {\n\t\t\tif (hiddenProperty && (hiddenProperty as { $Path: string }).$Path) {\n\t\t\t\thiddenPaths.push(\"%{\" + (hiddenProperty as { $Path: string }).$Path + \"}\");\n\t\t\t}\n\t\t});\n\n\t\treturn hiddenPaths.length ? \"{= \" + hiddenPaths.join(\" || \") + \" === true ? false : true }\" : false;\n\t},\n\n\t/**\n\t * This function returns the true/false to display chart.\n\t * @param chartType The chart type\n\t * @param value Data point value of Value\n\t * @param value.$Path\n\t * @param maxValue Data point value of MaximumValue\n\t * @param maxValue.$Path\n\t * @param valueHidden Hidden path object/boolean value for the referenced property of value\n\t * @param valueHidden.$Path\n\t * @param maxValueHidden Hidden path object/boolean value for the referenced property of MaxValue\n\t * @param maxValueHidden.$Path\n\t * @returns `true` or `false` to hide/show chart\n\t */\n\tisNotAlwaysHidden: function (\n\t\tchartType: string,\n\t\tvalue: { $Path: string },\n\t\tmaxValue: { $Path: string } | undefined,\n\t\tvalueHidden?: boolean | { $Path: string },\n\t\tmaxValueHidden?: boolean | { $Path: string }\n\t): boolean {\n\t\tif (valueHidden === true) {\n\t\t\tthis.logError(chartType, value);\n\t\t}\n\t\tif (maxValueHidden === true) {\n\t\t\tthis.logError(chartType, maxValue);\n\t\t}\n\t\tif (valueHidden === undefined && maxValueHidden === undefined) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn ((!valueHidden || (valueHidden as { $Path: string }).$Path) && valueHidden !== undefined) ||\n\t\t\t\t((!maxValueHidden || (maxValueHidden as { $Path: string }).$Path) && maxValueHidden !== undefined)\n\t\t\t\t? true\n\t\t\t\t: false;\n\t\t}\n\t},\n\n\t/**\n\t * This function is to log errors for missing data point properties.\n\t * @param chartType The chart type.\n\t * @param value Dynamic hidden property name.\n\t * @param value.$Path Dynamic hidden property name.\n\t */\n\tlogError: function (chartType: string, value?: { $Path: string }): void {\n\t\tLog.error(`Measure Property ${value?.$Path} is hidden for the ${chartType} Micro Chart`);\n\t},\n\n\t/**\n\t * This function returns the formatted value with scale factor for the value displayed.\n\t * @param path Property path for the value\n\t * @param property The Property for constraints\n\t * @param fractionDigits No. of fraction digits specified from annotations\n\t * @param value Static value of the property\n\t * @returns Expression Binding for the value with scale.\n\t */\n\tformatDecimal: function (path: string, property: Property, fractionDigits: number | undefined, value?: number): string | undefined {\n\t\tif (path) {\n\t\t\tconst constraints = [],\n\t\t\t\tformatOptions = [\"style: 'short'\"];\n\t\t\tconst scale = typeof fractionDigits === \"number\" ? fractionDigits : (property && property?.$Scale) || 1;\n\n\t\t\tif (property.$Nullable != undefined) {\n\t\t\t\tconstraints.push(\"nullable: \" + property.$Nullable);\n\t\t\t}\n\t\t\tif (property.$Precision != undefined) {\n\t\t\t\tformatOptions.push(\"precision: \" + (property.$Precision ? property.$Precision : \"1\"));\n\t\t\t}\n\t\t\tconstraints.push(\"scale: \" + (scale === \"variable\" ? \"'\" + scale + \"'\" : scale));\n\n\t\t\treturn (\n\t\t\t\t\"{ path: '\" +\n\t\t\t\tpath +\n\t\t\t\t\"'\" +\n\t\t\t\t\", type: 'sap.ui.model.odata.type.Decimal', constraints: { \" +\n\t\t\t\tconstraints.join(\",\") +\n\t\t\t\t\" }, formatOptions: { \" +\n\t\t\t\tformatOptions.join(\",\") +\n\t\t\t\t\" } }\"\n\t\t\t);\n\t\t} else if (value) {\n\t\t\tconst decimals = typeof fractionDigits === \"number\" ? fractionDigits : 1;\n\t\t\treturn NumberFormat.getFloatInstance({ style: \"short\", preserveDecimals: true, decimals: decimals }).format(value);\n\t\t}\n\t},\n\n\t/**\n\t * To fetch, the $select parameters from annotations to add to the list binding.\n\t * @param groupId GroupId to be used\n\t * @param sortOrder Sort order to be used\n\t * @param criticalityCalculation Criticality calculation object property path\n\t * @param criticality Criticality for the chart\n\t * @param otherPaths All other paths\n\t * @returns String containing all the property paths needed to be added to the $select query of the list binding.\n\t * @private\n\t */\n\tgetSelectParameters: function (\n\t\tgroupId: string,\n\t\tsortOrder?: SortOrderType[],\n\t\tcriticalityCalculation?: CriticalityCalculationType,\n\t\tcriticality?: string,\n\t\totherPaths?: string[]\n\t): string {\n\t\tconst propertyPath: string[] = [],\n\t\t\tsorters: string[] = [],\n\t\t\tparameters: string[] = [];\n\n\t\tif (groupId) {\n\t\t\tparameters.push(`$$groupId : '${groupId}'`);\n\t\t}\n\t\tif (sortOrder) {\n\t\t\tsortOrder.forEach((sorter: SortOrderType) => {\n\t\t\t\tsorters.push(`${sorter.Property}${sorter.Descending ? \" desc\" : \"\"}`);\n\t\t\t});\n\t\t}\n\n\t\tif (criticality) {\n\t\t\tpropertyPath.push(criticality);\n\t\t} else if (criticalityCalculation) {\n\t\t\tconst cricticalityCalculationKeys = [\n\t\t\t\t\"ImprovementDirection\",\n\t\t\t\t\"DeviationRangeLowValue\",\n\t\t\t\t\"ToleranceRangeLowValue\",\n\t\t\t\t\"AcceptanceRangeLowValue\",\n\t\t\t\t\"AcceptanceRangeHighValue\",\n\t\t\t\t\"ToleranceRangeHighValue\",\n\t\t\t\t\"DeviationRangeHighValue\"\n\t\t\t];\n\t\t\tObject.keys(criticalityCalculation).forEach((key: string) => {\n\t\t\t\tif (\n\t\t\t\t\tcricticalityCalculationKeys.includes(key) &&\n\t\t\t\t\t((criticalityCalculation as unknown as Record<string, string>)[key] as unknown as PathAnnotationExpression<string>).path\n\t\t\t\t) {\n\t\t\t\t\tpropertyPath.push(\n\t\t\t\t\t\t((criticalityCalculation as unknown as Record<string, string>)[key] as unknown as PathAnnotationExpression<string>)\n\t\t\t\t\t\t\t.path\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\totherPaths?.forEach((path) => {\n\t\t\tif (path) {\n\t\t\t\tpropertyPath.push(path);\n\t\t\t}\n\t\t});\n\n\t\tif (propertyPath.length) {\n\t\t\tparameters.push(`$select : '${propertyPath.join(\",\")}'`);\n\t\t}\n\t\tif (sorters.length) {\n\t\t\tparameters.push(`$orderby : '${sorters.join(\",\")}'`);\n\t\t}\n\n\t\treturn parameters.join(\",\");\n\t},\n\n\t/**\n\t * To fetch DataPoint qualifiers of measures.\n\t * @param chartAnnotations Chart annotations\n\t * @param entityTypeAnnotations EntityType annotations\n\t * @param chartType Chart type used\n\t * @returns Containing all data point qualifiers.\n\t * @private\n\t */\n\tgetDataPointQualifiersForMeasures: function (\n\t\tchartAnnotations: MetaModelType<Chart>,\n\t\tentityTypeAnnotations: MetaModelEntityTypeAnnotations | undefined,\n\t\tchartType: string\n\t): string {\n\t\tconst qualifiers: string[] = [],\n\t\t\tmeasureAttributes = chartAnnotations.MeasureAttributes,\n\t\t\tfnAddDataPointQualifier = function (chartMeasure: { $PropertyPath: string }): void {\n\t\t\t\tconst measure = chartMeasure.$PropertyPath;\n\t\t\t\tlet qualifier: string | undefined;\n\t\t\t\tif (entityTypeAnnotations) {\n\t\t\t\t\tmeasureAttributes?.forEach(function (measureAttribute: MetaModelType<ChartMeasureAttributeTypeTypes>) {\n\t\t\t\t\t\tif (measureAttribute.Measure?.$PropertyPath === measure && measureAttribute.DataPoint?.$AnnotationPath) {\n\t\t\t\t\t\t\tconst annotationPath = measureAttribute.DataPoint.$AnnotationPath;\n\t\t\t\t\t\t\tif (entityTypeAnnotations[annotationPath as keyof MetaModelEntityTypeAnnotations]) {\n\t\t\t\t\t\t\t\tqualifier = annotationPath.split(\"#\")[1];\n\t\t\t\t\t\t\t\tif (qualifier) {\n\t\t\t\t\t\t\t\t\tqualifiers.push(qualifier);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (qualifier === undefined) {\n\t\t\t\t\tLog.warning(\n\t\t\t\t\t\t`FE:Macro:MicroChart : Couldn't find DataPoint(Value) measure for the measureAttribute for ${chartType} MicroChart.`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t};\n\n\t\tif (!entityTypeAnnotations) {\n\t\t\tLog.warning(`FE:Macro:MicroChart : Couldn't find annotations for the DataPoint ${chartType} MicroChart.`);\n\t\t}\n\t\tchartAnnotations.Measures?.forEach(fnAddDataPointQualifier);\n\t\treturn qualifiers.join(\",\");\n\t},\n\n\t/**\n\t * This function is to log warnings for missing datapoint properties.\n\t * @param chartType The Chart type.\n\t * @param error Object with properties from DataPoint.\n\t */\n\tlogWarning: function (chartType: string, error: object): void {\n\t\tfor (const key in error) {\n\t\t\tif (!error[key as keyof typeof error]) {\n\t\t\t\tLog.warning(`${key} parameter is missing for the ${chartType} Micro Chart`);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * This function is used to get DisplayValue for comparison micro chart data aggregation.\n\t * @param dataPoint Data point object.\n\t * @param pathText Object after evaluating @com.sap.vocabularies.Common.v1.Text annotation\n\t * @param pathText.$Path The target path\n\t * @param valueTextPath Evaluation of @com.sap.vocabularies.Common.v1.Text/$Path/$ value of the annotation\n\t * @param valueDataPointPath DataPoint>Value/$Path/$ value after evaluating annotation\n\t * @returns Expression binding for Display Value for comparison micro chart's aggregation data.\n\t */\n\tgetDisplayValueForMicroChart: function (\n\t\tdataPoint: MetaModelType<DataPointType>,\n\t\tpathText: { $Path: string } | undefined,\n\t\tvalueTextPath: object,\n\t\tvalueDataPointPath: object\n\t): string | undefined {\n\t\tconst valueFormat = dataPoint.ValueFormat && dataPoint.ValueFormat.NumberOfFractionalDigits;\n\t\tif (pathText) {\n\t\t\treturn MicroChartHelper.formatDecimal(pathText[\"$Path\"], valueTextPath as Property, valueFormat);\n\t\t}\n\t\treturn MicroChartHelper.formatDecimal(dataPoint.Value[\"$Path\"], valueDataPointPath as Property, valueFormat);\n\t},\n\n\t/**\n\t * This function is used to check whether micro chart is enabled or not by checking properties, chart annotations, hidden properties.\n\t * @param chartType MicroChart Type,such as Bullet.\n\t * @param dataPoint Data point object.\n\t * @param dataPointValueHidden Object with $Path annotation to get the hidden value path\n\t * @param targetAnnotations ChartAnnotation object\n\t * @param dataPointMaxValue Object with $Path annotation to get hidden max value path\n\t * @returns `true` if the chart has all values and properties and also it is not always hidden sFinalDataPointValue && bMicrochartVisible.\n\t */\n\tshouldMicroChartRender: function (\n\t\tchartType: string,\n\t\tdataPoint: DataPointType,\n\t\tdataPointValueHidden: Record<string, boolean>,\n\t\ttargetAnnotations: Chart,\n\t\tdataPointMaxValue: Record<string, boolean>\n\t): boolean {\n\t\tconst availableChartTypes = [\"Area\", \"Column\", \"Comparison\"],\n\t\t\tdataPointValue = dataPoint && dataPoint.Value,\n\t\t\thiddenPath = dataPointValueHidden && dataPointValueHidden[UIAnnotationTerms.Hidden],\n\t\t\tchartAnnotationDimension = targetAnnotations && targetAnnotations.Dimensions && targetAnnotations.Dimensions[0],\n\t\t\tfinalDataPointValue = availableChartTypes.includes(chartType) ? dataPointValue && chartAnnotationDimension : dataPointValue; // only for three charts in array\n\t\tif (chartType === \"Harvey\") {\n\t\t\tconst dataPointMaximumValue = dataPoint && dataPoint.MaximumValue,\n\t\t\t\tmaxValueHiddenPath = dataPointMaxValue && dataPointMaxValue[UIAnnotationTerms.Hidden];\n\t\t\treturn (\n\t\t\t\tdataPointValue &&\n\t\t\t\tdataPointMaximumValue &&\n\t\t\t\tMicroChartHelper.isNotAlwaysHidden(\n\t\t\t\t\t\"Bullet\",\n\t\t\t\t\tdataPointValue,\n\t\t\t\t\tdataPointMaximumValue as unknown as { $Path: string },\n\t\t\t\t\thiddenPath,\n\t\t\t\t\tmaxValueHiddenPath\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\treturn finalDataPointValue && MicroChartHelper.isNotAlwaysHidden(chartType, dataPointValue, undefined, hiddenPath);\n\t},\n\n\t/**\n\t * This function is used to get dataPointQualifiers for Column, Comparison and StackedBar micro charts.\n\t * @param annotationPath\n\t * @returns Result string or undefined.\n\t */\n\tgetDataPointQualifiersForMicroChart: function (annotationPath: string): string | undefined {\n\t\tif (!annotationPath.includes(UIAnnotationTerms.DataPoint)) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn annotationPath.split(\"#\")[1] ?? \"\";\n\t},\n\n\t/**\n\t * This function is used to get colorPalette for comparison and HarveyBall Microcharts.\n\t * @param dataPoint Data point object.\n\t * @returns Result string for colorPalette or undefined.\n\t */\n\tgetColorPaletteForMicroChart: function (dataPoint: DataPointType): string | undefined {\n\t\treturn dataPoint.Criticality\n\t\t\t? undefined\n\t\t\t: \"sapUiChartPaletteQualitativeHue1, sapUiChartPaletteQualitativeHue2, sapUiChartPaletteQualitativeHue3,          sapUiChartPaletteQualitativeHue4, sapUiChartPaletteQualitativeHue5, sapUiChartPaletteQualitativeHue6, sapUiChartPaletteQualitativeHue7,          sapUiChartPaletteQualitativeHue8, sapUiChartPaletteQualitativeHue9, sapUiChartPaletteQualitativeHue10, sapUiChartPaletteQualitativeHue11\";\n\t},\n\n\t/**\n\t * This function is used to get MeasureScale for Area, Column and Line micro charts.\n\t * @param dataPoint Data point object.\n\t * @returns Data point value format fractional digits or data point scale or 1.\n\t */\n\tgetMeasureScaleForMicroChart: function (dataPoint: DataPointType): number {\n\t\tif (dataPoint.ValueFormat && dataPoint.ValueFormat.NumberOfFractionalDigits) {\n\t\t\treturn dataPoint.ValueFormat.NumberOfFractionalDigits.valueOf();\n\t\t}\n\t\tif (dataPoint.Value && dataPoint.Value[\"$Path\"] && dataPoint.Value[\"$Path\"][\"$Scale\"]) {\n\t\t\treturn dataPoint.Value[\"$Path\"][\"$Scale\"];\n\t\t}\n\t\treturn 1;\n\t},\n\n\t/**\n\t * This function is to return the binding expression of microchart.\n\t * @param chartType The type of micro chart (Bullet, Radial etc.)\n\t * @param measure Measure value for micro chart.\n\t * @param microChart `this`/current model for micro chart.\n\t * @param collection Collection object.\n\t * @param uiName The @sapui.name in collection model is not accessible here from model hence need to pass it.\n\t * @param dataPoint Data point object used in case of Harvey Ball micro chart\n\t * @returns The binding expression for micro chart.\n\t * @private\n\t */\n\tgetBindingExpressionForMicrochart: function (\n\t\tchartType: string,\n\t\tmeasure: DataModelObjectPath<Measure>,\n\t\tmicroChart: MicroChartBlock,\n\t\tcollection: MetaModelNavProperty,\n\t\tuiName: string,\n\t\tdataPoint: DataModelObjectPath<DataPointType>\n\t): string {\n\t\tconst condition = collection[\"$isCollection\"] || collection[\"$kind\"] === \"EntitySet\";\n\t\tconst path = condition ? \"\" : uiName;\n\t\tlet currencyOrUnit = MicroChartHelper.getUOMPathForMicrochart(microChart.showOnlyChart as boolean, measure);\n\t\tlet dataPointCriticallity = \"\";\n\t\tswitch (chartType) {\n\t\t\tcase \"Radial\":\n\t\t\t\tcurrencyOrUnit = \"\";\n\t\t\t\tbreak;\n\t\t\tcase \"Harvey\":\n\t\t\t\tdataPointCriticallity = dataPoint?.targetObject?.Criticality\n\t\t\t\t\t? (dataPoint.targetObject?.Criticality as PathAnnotationExpression<string>)?.path\n\t\t\t\t\t: \"\";\n\t\t\t\tbreak;\n\t\t}\n\t\tconst functionValue = MicroChartHelper.getSelectParameters(microChart.batchGroupId, undefined, undefined, dataPointCriticallity, [\n\t\t\tcurrencyOrUnit\n\t\t]);\n\n\t\treturn `{ path: '${path}'` + `, parameters : {${functionValue}} }`;\n\t},\n\n\t/**\n\t * This function is to return the UOMPath expression of the micro chart.\n\t * @param showOnlyChart Whether only chart should be rendered or not.\n\t * @param measure Measures for the micro chart.\n\t * @returns UOMPath String for the micro chart.\n\t * @private\n\t */\n\tgetUOMPathForMicrochart: function (showOnlyChart: boolean, measure?: DataModelObjectPath<Measure>): string {\n\t\treturn measure && !showOnlyChart\n\t\t\t? (\n\t\t\t\t\t(measure.targetObject?.annotations?.Measures as PropertyAnnotations_Measures)\n\t\t\t\t\t\t?.ISOCurrency as unknown as PathAnnotationExpression<string>\n\t\t\t  )?.path ||\n\t\t\t\t\t(\n\t\t\t\t\t\t(measure.targetObject?.annotations?.Measures as PropertyAnnotations_Measures)\n\t\t\t\t\t\t\t?.Unit as unknown as PathAnnotationExpression<string>\n\t\t\t\t\t)?.path ||\n\t\t\t\t\t\"\"\n\t\t\t: \"\";\n\t},\n\n\t/**\n\t * This function is to return the aggregation binding expression of micro chart.\n\t * @param aggregationType Aggregation type of chart (for example, Point for AreaMicrochart)\n\t * @param collection Collection object.\n\t * @param dataPoint Data point info for micro chart.\n\t * @param uiName The @sapui.name in collection model is not accessible here from model hence need to pass it.\n\t * @param dimension Micro chart Dimensions.\n\t * @param measure Measure value for micro chart.\n\t * @param sortOrder SortOrder for micro chart.\n\t * @param measureOrDimensionBar The measure or dimension passed specifically in the case of bar chart.\n\t * @returns Aggregation binding expression for micro chart.\n\t * @private\n\t */\n\tgetAggregationForMicrochart: function (\n\t\taggregationType: string,\n\t\tcollection: MetaModelNavProperty,\n\t\tdataPoint: DataModelObjectPath<DataPointType>,\n\t\tuiName: string,\n\t\tdimension: DataModelObjectPath<PropertyPath> | undefined,\n\t\tmeasure: DataModelObjectPath<Measure>,\n\t\tsortOrder: SortOrderType[],\n\t\tmeasureOrDimensionBar: string\n\t): string {\n\t\tlet path = collection[\"$kind\"] === \"EntitySet\" ? \"/\" : \"\";\n\t\tpath = path + uiName;\n\t\tconst groupId = \"\";\n\t\tlet dataPointCriticallityCalc;\n\t\tlet dataPointCriticallity = dataPoint.targetObject?.Criticality\n\t\t\t? (dataPoint.targetObject?.Criticality as PathAnnotationExpression<string>)?.path\n\t\t\t: \"\";\n\t\tconst currencyOrUnit = MicroChartHelper.getUOMPathForMicrochart(false, measure);\n\t\tlet targetValuePath = \"\";\n\t\tlet dimensionPropertyPath = \"\";\n\t\tif (dimension?.targetObject?.$target?.annotations?.Common?.Text) {\n\t\t\tdimensionPropertyPath = (\n\t\t\t\tdimension?.targetObject?.$target?.annotations?.Common?.Text as unknown as PathAnnotationExpression<string>\n\t\t\t)?.path;\n\t\t} else if (dimension) {\n\t\t\tdimensionPropertyPath = dimension.targetObject?.value as string;\n\t\t}\n\t\tswitch (aggregationType) {\n\t\t\tcase \"Points\":\n\t\t\t\tdataPointCriticallityCalc = dataPoint?.targetObject?.CriticalityCalculation;\n\t\t\t\ttargetValuePath = dataPoint?.targetObject?.TargetValue?.path;\n\t\t\t\tdataPointCriticallity = \"\";\n\t\t\t\tbreak;\n\t\t\tcase \"Columns\":\n\t\t\t\tdataPointCriticallityCalc = dataPoint?.targetObject?.CriticalityCalculation;\n\t\t\t\tbreak;\n\t\t\tcase \"LinePoints\":\n\t\t\t\tdataPointCriticallity = \"\";\n\t\t\t\tbreak;\n\t\t\tcase \"Bars\":\n\t\t\t\tdimensionPropertyPath = \"\";\n\t\t\t\tbreak;\n\t\t}\n\t\tconst functionValue = MicroChartHelper.getSelectParameters(groupId, sortOrder, dataPointCriticallityCalc, dataPointCriticallity, [\n\t\t\tcurrencyOrUnit,\n\t\t\ttargetValuePath,\n\t\t\tdimensionPropertyPath,\n\t\t\tmeasureOrDimensionBar\n\t\t]);\n\n\t\treturn `{path:'${path}'` + `, parameters : {${functionValue}} }`;\n\t},\n\n\tgetCurrencyOrUnit: function (measure: MetaModelPropertyAnnotations): string | undefined {\n\t\tif (measure[`@${MeasuresAnnotationTerms.ISOCurrency}`]) {\n\t\t\treturn (\n\t\t\t\t(measure[`@${MeasuresAnnotationTerms.ISOCurrency}`] as { $Path: string }).$Path ||\n\t\t\t\t(measure[`@${MeasuresAnnotationTerms.ISOCurrency}`] as string)\n\t\t\t);\n\t\t}\n\t\tif (measure[`@${MeasuresAnnotationTerms.Unit}`]) {\n\t\t\treturn (\n\t\t\t\t(measure[`@${MeasuresAnnotationTerms.Unit}`] as { $Path: string }).$Path ||\n\t\t\t\t(measure[`@${MeasuresAnnotationTerms.Unit}`] as string)\n\t\t\t);\n\t\t}\n\t\treturn \"\";\n\t},\n\n\tgetCalendarPattern: function (propertyType: string, annotations: Record<string, unknown>): {} | undefined {\n\t\treturn (\n\t\t\t(annotations[`@${CommonAnnotationTerms.IsCalendarYear}`] && \"yyyy\") ||\n\t\t\t(annotations[`@${CommonAnnotationTerms.IsCalendarQuarter}`] && \"Q\") ||\n\t\t\t(annotations[`@${CommonAnnotationTerms.IsCalendarMonth}`] && \"MM\") ||\n\t\t\t(annotations[`@${CommonAnnotationTerms.IsCalendarWeek}`] && \"ww\") ||\n\t\t\t(annotations[`@${CommonAnnotationTerms.IsCalendarDate}`] && \"yyyyMMdd\") ||\n\t\t\t(annotations[`@${CommonAnnotationTerms.IsCalendarYearMonth}`] && \"yyyyMM\") ||\n\t\t\t(propertyType === \"Edm.Date\" && \"yyyy-MM-dd\") ||\n\t\t\tundefined\n\t\t);\n\t},\n\n\tformatDimension: function (date: string, pattern: string, propertyPath: string): number {\n\t\tconst value = DateFormat.getDateInstance({ pattern }).parse(date, false, true);\n\t\tif (value instanceof Date) {\n\t\t\treturn value.getTime();\n\t\t} else {\n\t\t\tLog.warning(\"Date value could not be determined for \" + propertyPath);\n\t\t}\n\t\treturn 0;\n\t},\n\n\tformatStringDimension: function (value: unknown, pattern: string, propertyPath: string): number {\n\t\tif (pattern in calendarPatternMap) {\n\t\t\tconst matchedValue = value?.toString().match(calendarPatternMap[pattern]);\n\t\t\tif (matchedValue && matchedValue?.length) {\n\t\t\t\treturn MicroChartHelper.formatDimension(matchedValue[0], pattern, propertyPath);\n\t\t\t}\n\t\t}\n\t\tLog.warning(\"Pattern not supported for \" + propertyPath);\n\t\treturn 0;\n\t},\n\n\tgetX: function (propertyPath: string, propertyType: string, annotations?: Record<string, unknown>): string | undefined {\n\t\tconst pattern = annotations && MicroChartHelper.getCalendarPattern(propertyType, annotations);\n\t\tif (pattern && [\"Edm.Date\", \"Edm.String\"].some((type) => type === propertyType)) {\n\t\t\treturn `{parts: [{path: '${propertyPath}', targetType: 'any'}, {value: '${pattern}'}, {value: '${propertyPath}'}], formatter: 'MICROCHARTR.formatStringDimension'}`;\n\t\t}\n\t}\n};\n\nexport default MicroChartHelper;\n"],"mappings":"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","ignoreList":[]}