{"version":3,"file":"TableExport.js","names":["TableExport","_exports","_proto","prototype","setupMixin","_baseClass","this","downloadUrl","undefined","tableBindingInfo","setTableBindingInfo","bindingInfo","setDownloadUrl","async","getTableDefinition","enableAnalytics","table","getContent","propertyHelper","getPropertyHelper","columnsExportSettings","mdcColumn","getColumns","concat","getColumnExportSettings","bindingParameters","collectionKeys","getDataModelObjectForMetaPath","metaPath","contextPath","targetEntityType","keys","map","key","name","selectProperties","column","Array","isArray","property","join","forEach","includes","push","requestAtLeastProperties","requestAtLeast","prop","parameters","$search","$$aggregation","tableBinding","getRowBinding","downloadListBinding","getModel","bindList","getPath","getContext","sorter","filters","requestDownloadUrl","destroy","error","Log","debug","_onBeforeExport","exportEvent","isSplitMode","getParameter","splitCells","getSource","exportSettings","tableDefinition","updateExportSettings","columns","setStaticSizeLimit","exportColumns","workbook","index","length","exportColumn","resourceBundle","Library","getResourceBundleFor","label","getLocalizedText","translateBooleanValueForExport","setExportConfig","addTargetValueColumn","tableAPIDownloadUrl","getParent","dataSource","dataUrl","control","type","sizeLimit","exportRequestSize","falseValue","getText","trueValue","referencedColumn","find","propertyInfos","relativePath","toString","exportConfigList","targetValueColumn","isPropertyFromExport","columnWithTargetValueToBeAdded","columnToBeAdded","template","exportDataPointTargetValue","splice","columnExport","columnNeedsToBeAdded"],"sources":["./TableExport.ts"],"sourcesContent":["import Log from \"sap/base/Log\";\nimport type ResourceBundle from \"sap/base/i18n/ResourceBundle\";\nimport { type IInterfaceWithMixin } from \"sap/fe/base/ClassSupport\";\nimport {\n\ttype AnnotationTableColumn,\n\ttype ColumnExportSettings,\n\ttype TableColumn,\n\ttype TableVisualization\n} from \"sap/fe/core/converters/controls/Common/Table\";\nimport { getLocalizedText } from \"sap/fe/core/helpers/ResourceModelHelper\";\nimport { type CollectionBindingInfo } from \"sap/fe/macros/CollectionBindingInfo\";\nimport Library from \"sap/ui/core/Lib\";\nimport type MDCTable from \"sap/ui/mdc/Table\";\nimport { type Table$BeforeExportEvent } from \"sap/ui/mdc/Table\";\nimport type ODataModel from \"sap/ui/model/odata/v4/ODataModel\";\nimport { type ITableBlock } from \"../TableAPI\";\n\ntype ExportColumn = {\n\tproperty: string | string[];\n\tlabel: string;\n\tcolumnId?: string;\n\twidth?: number;\n\ttextAlign?: string;\n\tdisplayUnit?: boolean;\n\ttrueValue?: string;\n\tfalseValue?: string;\n\tvalueMap?: string;\n\ttemplate?: string;\n\ttype?: string;\n\tdelimiter?: boolean;\n\twrap?: boolean;\n\tunit?: string;\n\tscale?: number;\n};\n\ntype UserExportSettings = {\n\tsplitCells?: boolean;\n};\n\nexport type ExportSettings = {\n\tfileType?: string;\n\tdataSource: {\n\t\tdataUrl: string;\n\t\tsizeLimit?: number;\n\t};\n\tworkbook: {\n\t\tcolumns: ExportColumn[];\n\t};\n};\n\nexport default class TableExport implements IInterfaceWithMixin {\n\tdownloadUrl?: string;\n\n\ttableBindingInfo?: CollectionBindingInfo;\n\n\tsetupMixin(_baseClass: Function): void {\n\t\tthis.downloadUrl = undefined;\n\t\tthis.tableBindingInfo = undefined;\n\t}\n\n\t/**\n\t * Stores the binding info for the table used to create the list binding.\n\t * @param bindingInfo\n\t */\n\tsetTableBindingInfo(bindingInfo: CollectionBindingInfo): void {\n\t\tthis.tableBindingInfo = bindingInfo;\n\t}\n\n\t/**\n\t * Compute the download URL to be used by the export and store it in the TableAPI.\n\t * @param this\n\t * @returns Promise when downloadUrl is set\n\t */\n\tasync setDownloadUrl(this: ITableBlock & TableExport): Promise<void> {\n\t\t//empty the downloadUrl to prevent an invalid one to be used\n\t\tthis.downloadUrl = undefined;\n\n\t\tif (this.getTableDefinition().enableAnalytics === true) {\n\t\t\t// In case of an analytical table, $select is not supported, so we don't calculate the download URL (we use the default behaviour)\n\t\t\treturn;\n\t\t}\n\n\t\tlet downloadUrl: string | undefined | null;\n\t\tconst table = this.getContent();\n\t\ttry {\n\t\t\tconst propertyHelper = table.getPropertyHelper();\n\t\t\tlet columnsExportSettings: ExportColumn[] = [];\n\t\t\tfor (const mdcColumn of table.getColumns()) {\n\t\t\t\tcolumnsExportSettings = columnsExportSettings.concat(propertyHelper.getColumnExportSettings(mdcColumn));\n\t\t\t}\n\n\t\t\tconst bindingParameters: { $select?: string; $search?: string; $$aggregation?: object } = {};\n\t\t\t// we just want to request the properties necessary for the export\n\t\t\tconst collectionKeys = this.getDataModelObjectForMetaPath(this.metaPath, this.contextPath)?.targetEntityType.keys.map(\n\t\t\t\t(key) => key.name\n\t\t\t);\n\t\t\tconst selectProperties = columnsExportSettings.map((column: ExportColumn) => {\n\t\t\t\treturn Array.isArray(column.property) ? column.property.join(\",\") : column.property;\n\t\t\t});\n\t\t\tcollectionKeys?.forEach((key) => {\n\t\t\t\tif (!selectProperties.includes(key)) {\n\t\t\t\t\tselectProperties.push(key);\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst requestAtLeastProperties = this.getTableDefinition().requestAtLeast;\n\t\t\trequestAtLeastProperties?.forEach((prop) => {\n\t\t\t\tif (!selectProperties.includes(prop)) {\n\t\t\t\t\tselectProperties.push(prop);\n\t\t\t\t}\n\t\t\t});\n\t\t\tbindingParameters[\"$select\"] = selectProperties.join(\",\");\n\n\t\t\tif (this.tableBindingInfo?.parameters?.$search) {\n\t\t\t\tbindingParameters.$search = this.tableBindingInfo.parameters.$search;\n\t\t\t}\n\n\t\t\tif (this.tableBindingInfo?.parameters?.$$aggregation) {\n\t\t\t\tbindingParameters.$$aggregation = this.tableBindingInfo.parameters.$$aggregation;\n\t\t\t}\n\n\t\t\tconst tableBinding = table.getRowBinding();\n\t\t\t// we create a list binding to compute the right url for the export from its binding parameters\n\t\t\tconst downloadListBinding = (tableBinding.getModel() as ODataModel).bindList(\n\t\t\t\ttableBinding.getPath(),\n\t\t\t\ttableBinding.getContext(),\n\t\t\t\tthis.tableBindingInfo?.sorter,\n\t\t\t\tthis.tableBindingInfo?.filters,\n\t\t\t\tbindingParameters\n\t\t\t);\n\t\t\tdownloadUrl = await downloadListBinding.requestDownloadUrl();\n\t\t\tdownloadListBinding.destroy();\n\t\t} catch (error: unknown) {\n\t\t\tLog.debug(\"Error while computing the download URL for the export\", error as Error);\n\t\t}\n\t\tif (downloadUrl) {\n\t\t\tthis.downloadUrl = downloadUrl;\n\t\t}\n\t}\n\n\t/**\n\t * Intercept the export before it's triggered to cover specific cases that couldn't be addressed on the propertyInfos for each column.\n\t * e.g. Fixed Target Value for the datapoints.\n\t * @param this\n\t * @param exportEvent\n\t */\n\t_onBeforeExport(this: ITableBlock & TableExport, exportEvent: Table$BeforeExportEvent): void {\n\t\tconst isSplitMode = (exportEvent.getParameter(\"userExportSettings\") as UserExportSettings)?.splitCells === true;\n\t\tconst table = exportEvent.getSource(),\n\t\t\texportSettings = exportEvent.getParameter(\"exportSettings\") as ExportSettings,\n\t\t\ttableDefinition = this.getTableDefinition();\n\n\t\tTableExport.updateExportSettings(exportSettings, tableDefinition, table, isSplitMode);\n\t}\n\n\t/**\n\t * Updates the table columns that can be exported.\n\t * @param exportSettings The table export settings\n\t * @param tableDefinition The table definition from the table converter\n\t * @param table The table\n\t * @param isSplitMode Defines if the export has been launched using split mode\n\t * @returns The updated columns to be exported\n\t */\n\tstatic updateExportSettings(\n\t\texportSettings: ExportSettings,\n\t\ttableDefinition: TableVisualization,\n\t\ttable: MDCTable,\n\t\tisSplitMode: boolean\n\t): ExportSettings {\n\t\tconst columns = tableDefinition.columns;\n\t\tthis.setStaticSizeLimit(tableDefinition, exportSettings);\n\t\tconst exportColumns = exportSettings.workbook.columns;\n\t\tfor (let index = exportColumns.length - 1; index >= 0; index--) {\n\t\t\tconst exportColumn = exportColumns[index];\n\t\t\tconst resourceBundle = Library.getResourceBundleFor(\"sap.fe.macros\")!;\n\t\t\texportColumn.label = getLocalizedText(exportColumn.label, table);\n\t\t\tthis.translateBooleanValueForExport(exportColumn, resourceBundle);\n\t\t\tif (isSplitMode) {\n\t\t\t\tthis.setExportConfig(columns, exportColumns, index);\n\t\t\t\tthis.addTargetValueColumn(columns, exportColumns, resourceBundle, index);\n\t\t\t}\n\t\t}\n\t\tconst tableAPIDownloadUrl = (table.getParent() as ITableBlock & TableExport).downloadUrl;\n\t\tif (tableAPIDownloadUrl) {\n\t\t\texportSettings.dataSource.dataUrl = tableAPIDownloadUrl;\n\t\t}\n\t\treturn exportSettings;\n\t}\n\n\t/**\n\t * Sets the static size limit for the table export.\n\t * @param tableDefinition The table definition from the table converter\n\t * @param exportSettings The table export settings\n\t */\n\tstatic setStaticSizeLimit(tableDefinition: TableVisualization, exportSettings: ExportSettings): void {\n\t\tif (\n\t\t\t!tableDefinition.enableAnalytics &&\n\t\t\t(tableDefinition.control.type === \"ResponsiveTable\" || tableDefinition.control.type === \"GridTable\")\n\t\t) {\n\t\t\texportSettings.dataSource.sizeLimit = tableDefinition.control.exportRequestSize ?? 1000;\n\t\t}\n\t}\n\n\t/**\n\t * Sets the translated textual representation of a column with boolean value.\n\t * @param exportColumn The column to be exported\n\t * @param resourceBundle The resource bundle\n\t */\n\tstatic translateBooleanValueForExport(exportColumn: ExportColumn, resourceBundle: ResourceBundle): void {\n\t\tif (exportColumn.type === \"Boolean\") {\n\t\t\texportColumn.falseValue = resourceBundle.getText(\"no\");\n\t\t\texportColumn.trueValue = resourceBundle.getText(\"yes\");\n\t\t}\n\t}\n\n\t/**\n\t * Sets the originating export config of a single property referenced on a field group or a custom column.\n\t * @param columns The columns from the table converter\n\t * @param exportColumns The list of columns to be exported\n\t * @param index The index of the column to be exported\n\t */\n\tstatic setExportConfig(columns: TableColumn[], exportColumns: ExportColumn[], index: number): void {\n\t\tconst referencedColumn = columns.find(\n\t\t\t(column) => !column.propertyInfos && (column as AnnotationTableColumn).relativePath === exportColumns[index].property.toString()\n\t\t);\n\t\tif (referencedColumn?.exportSettings) {\n\t\t\t// All export settings of a column to be exported can't be added to the export settings object\n\t\t\t// because column could have units/timezones/currencies that aren't required on custom customs but only on columns from annotations\n\t\t\tconst exportConfigList: Array<keyof ColumnExportSettings> = [\"scale\", \"delimiter\", \"format\", \"utc\", \"type\", \"inputFormat\"];\n\t\t\tfor (const key of exportConfigList) {\n\t\t\t\tif (referencedColumn.exportSettings[key]) {\n\t\t\t\t\texportColumns[index] = { ...exportColumns[index], ...{ [key]: referencedColumn.exportSettings[key] } };\n\t\t\t\t\tif (exportColumns[index].type === \"Currency\") {\n\t\t\t\t\t\texportColumns[index].type = \"Number\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Adds a target value column when there is a datapoint column.\n\t * @param columns The columns from the table converter\n\t * @param exportColumns The list of columns to be exported\n\t * @param resourceBundle The resource bundle\n\t * @param index The index of the column to be exported\n\t */\n\tstatic addTargetValueColumn(\n\t\tcolumns: TableColumn[],\n\t\texportColumns: ExportColumn[],\n\t\tresourceBundle: ResourceBundle,\n\t\tindex: number\n\t): void {\n\t\tconst targetValueColumn = (columns as AnnotationTableColumn[])?.find((column) => {\n\t\t\tif (!this.isPropertyFromExport(column, exportColumns[index])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn this.columnWithTargetValueToBeAdded(column, exportColumns[index]);\n\t\t});\n\t\tif (targetValueColumn) {\n\t\t\tconst columnToBeAdded: ExportColumn = {\n\t\t\t\tlabel: resourceBundle.getText(\"TargetValue\"),\n\t\t\t\tproperty: Array.isArray(exportColumns[index].property)\n\t\t\t\t\t? exportColumns[index].property\n\t\t\t\t\t: ([exportColumns[index].property] as string[]),\n\t\t\t\ttemplate: targetValueColumn.exportDataPointTargetValue\n\t\t\t};\n\t\t\texportColumns.splice(index + 1, 0, columnToBeAdded);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the column's property corresponds to the exportColumn.\n\t * @param column The column from the annotations column\n\t * @param exportColumn The column to be exported\n\t * @returns `true` Whether the column has the exportColumn property\n\t */\n\tstatic isPropertyFromExport(column: AnnotationTableColumn, exportColumn: ExportColumn): boolean {\n\t\tif (\n\t\t\tcolumn.relativePath === exportColumn.property ||\n\t\t\texportColumn.property.includes(column.relativePath) ||\n\t\t\texportColumn.property.includes(column.name)\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\t// In case of complex properties\n\t\tif (column.propertyInfos?.length === 1 && exportColumn.property[0] === column.propertyInfos[0]) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Defines if a column that is to be exported and contains a DataPoint with a fixed target value needs to be added.\n\t * @param column The column from the annotations column\n\t * @param columnExport The column to be exported\n\t * @returns `true` if the referenced column has defined a targetValue for the dataPoint, false else\n\t * @private\n\t */\n\tstatic columnWithTargetValueToBeAdded(column: AnnotationTableColumn, columnExport: ExportColumn): boolean {\n\t\tlet columnNeedsToBeAdded = false;\n\t\tif (column.exportDataPointTargetValue && column.propertyInfos?.length === 1) {\n\t\t\t//Add TargetValue column when exporting on split mode\n\t\t\t// part of a FieldGroup or from a lineItem or from a column on the entitySet\n\t\t\tdelete columnExport.template;\n\t\t\tcolumnNeedsToBeAdded = true;\n\t\t}\n\t\treturn columnNeedsToBeAdded;\n\t}\n}\n"],"mappings":"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","ignoreList":[]}