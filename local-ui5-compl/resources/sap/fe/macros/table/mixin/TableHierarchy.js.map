{"version":3,"file":"TableHierarchy.js","names":["DropPosition","TableHierarchy","_exports","_proto","prototype","setupMixin","_baseClass","_onCut","evt","forContextMenu","arguments","length","undefined","table","getSource","getParent","menu","internalContext","getBindingContext","selectedContexts","this","getSelectedContexts","Log","error","setProperty","MessageToast","show","ResourceModelHelper","getResourceModel","getText","getProperty","TableRuntime","clearSelection","fireSelectionChange","cutableContextsPath","_onDragEnterDocument","ui5Event","draggedContext","getParameter","getContent","getRowBinding","getBinding","preventDefault","targetContext","isAncestorOf","disabledBetween","disabledOn","tableDefinition","getTableDefinition","isMoveAllowedInfo","control","isMoveToPositionAllowed","customFunction","FPMHelper","getCustomFunction","moduleName","methodName","safeIsMoveAllowed","annotation","allowDropBetweenNodes","Math","abs","getIndex","getLength","changeSiblingForRootsSupported","isDropBetweenAllowedForDrag","allowedDropPosition","OnOrBetween","On","Between","setDropPosition","_onDragStartDocument","context","updatablePropertyPath","disableDrag","isRelative","isMovableInfo","isNodeMovable","_error","_onDropDocument","async","BusyLocker","lock","droppedOnContext","dropInfo","position","parentContext","contextBefore","contextAfter","getContextAfter","getContextBefore","Promise","all","dropContext","requestSideEffectsForChangeNextSiblingAction","getTranslatedText","message","unlock","_onCollapseExpandNode","_ui5Event","expand","promiseArray","map","singleContext","isExpanded","collapse","Number","MAX_SAFE_INTEGER","_onMoveUpDown","moveUp","movedContext","requestParent","contextMoved","movePromise","previousSibling","requestSibling","move","nextSibling","parent","newIndex","mdcTable","scrollToIndex","focusRow","entityPath","data","tableContext","model","getModel","metaModel","getMetaModel","targetObject","getContext","convertMetaModelContext","MetaModelConverter","entityType","targetType","actionName","annotations","Hierarchy","hierarchyQualifier","ChangeNextSiblingAction","appComponent","CommonUtils","getAppComponent","sideEffectsService","getSideEffectsService","sideEffects","getODataActionSideEffects","requestSideEffectsForODataAction","allowed","isAllowed","parentBefore","paramsBefore","getDropBetweenParameters","parentAfter","paramsAfter","contextIndex","Error","listBinding","getAllCurrentContexts","find","ctx","info","internalModelContext","isTableSorted","moveContext","params"],"sources":["./TableHierarchy.ts"],"sourcesContent":["import type { EntitySet, NavigationProperty } from \"@sap-ux/vocabularies-types\";\nimport Log from \"sap/base/Log\";\nimport { type IInterfaceWithMixin } from \"sap/fe/base/ClassSupport\";\nimport CommonUtils from \"sap/fe/core/CommonUtils\";\nimport BusyLocker from \"sap/fe/core/controllerextensions/BusyLocker\";\nimport * as MetaModelConverter from \"sap/fe/core/converters/MetaModelConverter\";\nimport FPMHelper from \"sap/fe/core/helpers/FPMHelper\";\nimport { type InternalModelContext } from \"sap/fe/core/helpers/ModelHelper\";\nimport ResourceModelHelper from \"sap/fe/core/helpers/ResourceModelHelper\";\nimport type Menu from \"sap/m/Menu\";\nimport MessageToast from \"sap/m/MessageToast\";\nimport type UI5Event from \"sap/ui/base/Event\";\nimport type Control from \"sap/ui/core/Control\";\nimport type UI5Element from \"sap/ui/core/Element\";\nimport type DragDropInfo from \"sap/ui/core/dnd/DragDropInfo\";\nimport type MDCTable from \"sap/ui/mdc/Table\";\nimport type Context from \"sap/ui/model/odata/v4/Context\";\nimport type ODataListBinding from \"sap/ui/model/odata/v4/ODataListBinding\";\nimport { type ITableBlock } from \"../TableAPI\";\nimport TableRuntime from \"../TableRuntime\";\n\nenum DropPosition {\n\tOn = \"On\",\n\tBetween = \"Between\",\n\tOnOrBetween = \"OnOrBetween\"\n}\n\ntype DropInformation =\n\t| { position: DropPosition.On; parentContext: Context | null }\n\t| { position: DropPosition.Between; contextBefore: Context | null; contextAfter: Context | null };\n\nexport default class TableHierarchy implements IInterfaceWithMixin {\n\tsetupMixin(_baseClass: Function): void {\n\t\t// This method is needed to implement interface IInterfaceWithMixin\n\t}\n\n\t/**\n\t * Handles the Cut operation.\n\t * @param evt The UI5 event\n\t * @param forContextMenu\n\t */\n\t_onCut(this: ITableBlock & TableHierarchy, evt: UI5Event<{}, UI5Element>, forContextMenu = false): void {\n\t\tlet table: MDCTable;\n\t\tif (!forContextMenu) {\n\t\t\ttable = evt.getSource().getParent() as MDCTable;\n\t\t} else {\n\t\t\tconst menu = evt.getSource().getParent() as Menu;\n\t\t\ttable = menu.getParent()?.getParent() as MDCTable;\n\t\t}\n\t\tconst internalContext = table.getBindingContext(\"internal\") as InternalModelContext;\n\t\tconst selectedContexts = this.getSelectedContexts();\n\t\tif (selectedContexts.length > 1) {\n\t\t\tLog.error(\"Multi cutting is not supported\");\n\t\t\treturn;\n\t\t}\n\n\t\tinternalContext.setProperty(\"pastableContexts\", selectedContexts);\n\t\tMessageToast.show(ResourceModelHelper.getResourceModel(table).getText(\"M_CUT_READY\"));\n\t\tif (!forContextMenu || internalContext.getProperty(\"numberOfSelectedContexts\") > 0) {\n\t\t\tTableRuntime.clearSelection(table);\n\t\t\ttable.fireSelectionChange();\n\t\t}\n\t\tconst cutableContextsPath = !forContextMenu ? \"cutableContexts\" : \"contextmenu/cutableContexts\";\n\t\tinternalContext.setProperty(cutableContextsPath, []);\n\t}\n\n\t/**\n\t * The dragged element enters a table row.\n\t * @param ui5Event UI5 event coming from the MDC drag and drop config\n\t */\n\t_onDragEnterDocument(\n\t\tthis: ITableBlock & TableHierarchy,\n\t\tui5Event: UI5Event<{ bindingContext: Context; dragSource: Context; dropPosition: \"Before\" | \"After\" | \"On\" }, DragDropInfo>\n\t): void {\n\t\tconst draggedContext = ui5Event.getParameter(\"dragSource\");\n\t\tif (this.getContent().getRowBinding() !== draggedContext.getBinding()) {\n\t\t\t// The drag is done on a different table -> not authorized\n\t\t\tui5Event.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\tconst targetContext: Context | null = ui5Event.getParameter(\"bindingContext\");\n\t\tif (draggedContext.isAncestorOf(targetContext)) {\n\t\t\t// The ancestor is dropped on a descendant -> not authorized\n\t\t\tui5Event.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\tlet disabledBetween = false;\n\t\tlet disabledOn = false;\n\t\tconst tableDefinition = this.getTableDefinition();\n\t\tconst isMoveAllowedInfo = tableDefinition.control.isMoveToPositionAllowed;\n\t\tconst customFunction = isMoveAllowedInfo\n\t\t\t? FPMHelper.getCustomFunction<(node: Context, parent: Context | null) => boolean>(\n\t\t\t\t\tisMoveAllowedInfo.moduleName,\n\t\t\t\t\tisMoveAllowedInfo.methodName,\n\t\t\t\t\tui5Event.getSource().getParent() as Control\n\t\t\t  )\n\t\t\t: undefined;\n\n\t\tif (targetContext === this.getContent().getBindingContext()) {\n\t\t\t// The drag is done on the table itself -> drop as root node)\n\t\t\tdisabledOn = !this.safeIsMoveAllowed(customFunction, draggedContext, null);\n\t\t\tdisabledBetween = true;\n\t\t} else {\n\t\t\tdisabledOn = !this.safeIsMoveAllowed(customFunction, draggedContext, targetContext);\n\t\t\tdisabledBetween = tableDefinition.annotation.allowDropBetweenNodes !== true;\n\n\t\t\tif (\n\t\t\t\tMath.abs(targetContext.getIndex()! - draggedContext.getIndex()!) === 1 &&\n\t\t\t\t!(targetContext.getIndex() === 0 && ui5Event.getParameter(\"dropPosition\") === \"Before\") &&\n\t\t\t\t!(\n\t\t\t\t\ttargetContext.getIndex() === this.getContent().getRowBinding().getLength() - 1 &&\n\t\t\t\t\tui5Event.getParameter(\"dropPosition\") === \"After\"\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t//\n\t\t\t\tdisabledBetween = true;\n\t\t\t}\n\n\t\t\t// If the drop between node is allowed, we need to check if the target is a root node and if the table supports changeSiblingForRoots\n\t\t\tif (\n\t\t\t\t!disabledBetween &&\n\t\t\t\t!tableDefinition.annotation.changeSiblingForRootsSupported &&\n\t\t\t\ttargetContext.getProperty(\"@$ui5.node.level\") === 1\n\t\t\t) {\n\t\t\t\tdisabledBetween = true;\n\t\t\t}\n\n\t\t\t// Check custom logic for drop between if there's some, and if it's not already disabled at the table level\n\t\t\tif (customFunction && !disabledBetween) {\n\t\t\t\tdisabledBetween = !this.isDropBetweenAllowedForDrag(customFunction, draggedContext, targetContext);\n\t\t\t}\n\t\t}\n\n\t\tlet allowedDropPosition: DropPosition = DropPosition.OnOrBetween;\n\t\tif (disabledBetween && disabledOn) {\n\t\t\t//Set the element as non droppable\n\t\t\tui5Event.preventDefault();\n\t\t\treturn;\n\t\t}\n\t\tif (disabledBetween) {\n\t\t\tallowedDropPosition = DropPosition.On;\n\t\t} else if (disabledOn) {\n\t\t\tallowedDropPosition = DropPosition.Between;\n\t\t}\n\t\tui5Event.getSource().setDropPosition(allowedDropPosition);\n\t}\n\n\t/**\n\t * Starts the drag of the document.\n\t * @param ui5Event UI5 event coming from the MDC drag and drop config\n\t */\n\t_onDragStartDocument(this: ITableBlock & TableHierarchy, ui5Event: UI5Event<{ bindingContext: Context }, Control>): void {\n\t\tconst context = ui5Event.getParameter(\"bindingContext\");\n\t\tconst updatablePropertyPath = this.getTableDefinition().annotation.updatablePropertyPath;\n\n\t\t// Check if the context can be updated according to update restrictions\n\t\tlet disableDrag = !!updatablePropertyPath && !context.getProperty(updatablePropertyPath);\n\n\t\t// In case of a TreeTable in a ListReport with draft, check that the context has no associated draft\n\t\tif (!disableDrag && !(context.getBinding() as ODataListBinding).isRelative()) {\n\t\t\tdisableDrag = context.getProperty(\"HasDraftEntity\") === true;\n\t\t}\n\n\t\t// Apply custom logic if there's one\n\t\tconst isMovableInfo = this.getTableDefinition().control.isNodeMovable;\n\t\ttry {\n\t\t\tif (isMovableInfo && !disableDrag) {\n\t\t\t\tdisableDrag =\n\t\t\t\t\t(\n\t\t\t\t\t\tFPMHelper.getCustomFunction<(contexts: Context[]) => boolean>(\n\t\t\t\t\t\t\tisMovableInfo.moduleName,\n\t\t\t\t\t\t\tisMovableInfo.methodName,\n\t\t\t\t\t\t\tui5Event.getSource()\n\t\t\t\t\t\t) as Function\n\t\t\t\t\t)(context) === false;\n\t\t\t}\n\t\t} catch (_error) {\n\t\t\tdisableDrag = false;\n\t\t}\n\t\tif (disableDrag) {\n\t\t\t//Set the element as non draggable\n\t\t\tui5Event.preventDefault();\n\t\t}\n\t}\n\n\t/**\n\t * Drops the document.\n\t * @param ui5Event UI5 event coming from the MDC drag and drop config\n\t * @returns The Promise\n\t */\n\tasync _onDropDocument(\n\t\tthis: ITableBlock & TableHierarchy,\n\t\tui5Event: UI5Event<{\n\t\t\tbindingContext: Context;\n\t\t\tdragSource: Context;\n\t\t\tdropPosition: string;\n\t\t}>\n\t): Promise<void> {\n\t\tBusyLocker.lock(this.getContent());\n\n\t\ttry {\n\t\t\tconst droppedOnContext = ui5Event.getParameter(\"bindingContext\");\n\t\t\tlet dropInfo: DropInformation;\n\t\t\tif (droppedOnContext === this.getContent().getBindingContext()) {\n\t\t\t\t// The drop is done on the table itself -> drop as root node)\n\t\t\t\tdropInfo = { position: DropPosition.On, parentContext: null };\n\t\t\t} else if (ui5Event.getParameter(\"dropPosition\") === DropPosition.On) {\n\t\t\t\t// Drop on a node\n\t\t\t\tdropInfo = { position: DropPosition.On, parentContext: droppedOnContext };\n\t\t\t} else {\n\t\t\t\t// Drop between 2 nodes\n\t\t\t\tlet contextBefore: Context | null;\n\t\t\t\tlet contextAfter: Context | null;\n\t\t\t\tif (ui5Event.getParameter(\"dropPosition\") === \"After\") {\n\t\t\t\t\tcontextBefore = droppedOnContext;\n\t\t\t\t\tcontextAfter = this.getContextAfter(droppedOnContext);\n\t\t\t\t} else {\n\t\t\t\t\tcontextBefore = this.getContextBefore(droppedOnContext);\n\t\t\t\t\tcontextAfter = droppedOnContext;\n\t\t\t\t}\n\t\t\t\tdropInfo = { position: DropPosition.Between, contextAfter, contextBefore };\n\t\t\t}\n\n\t\t\tawait Promise.all([\n\t\t\t\tthis.dropContext(ui5Event.getParameter(\"dragSource\"), dropInfo),\n\t\t\t\tthis.requestSideEffectsForChangeNextSiblingAction()\n\t\t\t]);\n\t\t} catch (error) {\n\t\t\tMessageToast.show(this.getTranslatedText(\"M_TABLEDROP_FAILED\", [(error as Error).message ?? \"\"]));\n\t\t} finally {\n\t\t\tBusyLocker.unlock(this.getContent());\n\t\t}\n\t}\n\n\t/**\n\t * Handler for collapse/expand from the context menu.\n\t * @param this\n\t * @param _ui5Event\n\t * @param expand\n\t */\n\tasync _onCollapseExpandNode(this: ITableBlock & TableHierarchy, _ui5Event: UI5Event, expand: boolean): Promise<void> {\n\t\tconst selectedContexts = this.getSelectedContexts();\n\t\tif (expand) {\n\t\t\tconst promiseArray = selectedContexts.map(async (singleContext: Context) => {\n\t\t\t\t// Checking for false specifically; undefined means the node cannot expand/collapse\n\t\t\t\tif (singleContext.isExpanded() !== undefined) {\n\t\t\t\t\t// Temporary workaround due to model limitation.\n\t\t\t\t\t// We need to collapse a node before expanding it to ensure we expand it completely.\n\t\t\t\t\t// Will be changed once the model fixes the issue.\n\t\t\t\t\tif (singleContext.isExpanded() === true) {\n\t\t\t\t\t\tawait singleContext.collapse();\n\t\t\t\t\t}\n\t\t\t\t\treturn singleContext.expand(Number.MAX_SAFE_INTEGER);\n\t\t\t\t}\n\t\t\t});\n\t\t\tawait Promise.all(promiseArray);\n\t\t} else {\n\t\t\tawait Promise.all(\n\t\t\t\tselectedContexts.map(async (singleContext: Context) => {\n\t\t\t\t\tif (singleContext.isExpanded() === true) {\n\t\t\t\t\t\treturn singleContext.collapse(true);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Internal method to move a row up or down in a Tree table.\n\t * @param _ui5Event\n\t * @param moveUp True for move up, false for move down\n\t * @param forContextMenu\n\t */\n\tasync _onMoveUpDown(this: ITableBlock & TableHierarchy, _ui5Event: UI5Event, moveUp: boolean, forContextMenu = false): Promise<void> {\n\t\tconst selectedContexts = this.getSelectedContexts();\n\t\tif (selectedContexts.length !== 1) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Move the context up or down\n\t\tconst movedContext = selectedContexts[0];\n\t\tconst parentContext = await movedContext.requestParent();\n\t\tlet contextMoved = false;\n\t\tlet movePromise = null;\n\t\tif (moveUp) {\n\t\t\tconst previousSibling = await movedContext.requestSibling(-1);\n\t\t\tif (previousSibling) {\n\t\t\t\tmovePromise = movedContext.move({ nextSibling: previousSibling, parent: parentContext });\n\t\t\t\tcontextMoved = true;\n\t\t\t}\n\t\t} else {\n\t\t\tconst nextSibling = await movedContext.requestSibling(1);\n\t\t\tif (nextSibling) {\n\t\t\t\tmovePromise = nextSibling.move({ nextSibling: movedContext, parent: parentContext });\n\t\t\t\tcontextMoved = true;\n\t\t\t}\n\t\t}\n\n\t\tawait Promise.all([movePromise, this.requestSideEffectsForChangeNextSiblingAction()]);\n\n\t\t// Scroll to the new position\n\t\tconst newIndex = movedContext.getIndex();\n\t\tif (contextMoved && newIndex !== undefined && newIndex >= 0) {\n\t\t\tconst mdcTable = this.getContent();\n\t\t\tif (!forContextMenu) {\n\t\t\t\tmdcTable.scrollToIndex(newIndex);\n\t\t\t} else {\n\t\t\t\tmdcTable.focusRow(newIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Requests the side effect for the ChangeNextSiblingAction.\n\t * @returns A Promise\n\t */\n\tasync requestSideEffectsForChangeNextSiblingAction(this: ITableBlock & TableHierarchy): Promise<void> {\n\t\tconst entityPath = this.getContent().data(\"metaPath\");\n\t\tconst tableContext = this.getContent().getBindingContext() as Context;\n\t\tconst model = tableContext.getModel(),\n\t\t\tmetaModel = model.getMetaModel();\n\n\t\tconst targetObject = metaModel.getContext(entityPath);\n\t\tconst convertMetaModelContext = MetaModelConverter.convertMetaModelContext(targetObject) as NavigationProperty | EntitySet;\n\t\tconst entityType = (convertMetaModelContext as NavigationProperty).targetType ?? (convertMetaModelContext as EntitySet).entityType;\n\t\tconst actionName = entityType.annotations.Hierarchy?.[\n\t\t\t`RecursiveHierarchyActions#${this.getTableDefinition().control.hierarchyQualifier ?? \"\"}`\n\t\t]?.ChangeNextSiblingAction as string | undefined;\n\n\t\tif (actionName) {\n\t\t\tconst appComponent = CommonUtils.getAppComponent(this.getContent());\n\t\t\tconst sideEffectsService = appComponent.getSideEffectsService();\n\t\t\tconst sideEffects = sideEffectsService.getODataActionSideEffects(actionName, tableContext);\n\t\t\tif (sideEffects) {\n\t\t\t\tawait sideEffectsService.requestSideEffectsForODataAction(sideEffects, tableContext);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Safely checks if moving a node is allowed.\n\t * @param customFunction\n\t * @param movedContext\n\t * @param parentContext\n\t * @returns True if allowed\n\t */\n\tprivate safeIsMoveAllowed(\n\t\tcustomFunction: ((context: Context, parent: Context | null) => boolean) | undefined,\n\t\tmovedContext: Context,\n\t\tparentContext: Context | null\n\t): boolean {\n\t\tif (!customFunction) {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet allowed = true;\n\t\ttry {\n\t\t\tallowed = customFunction(movedContext, parentContext) === true;\n\t\t} catch (error) {\n\t\t\tLog.error(\"Cannot execute function related to isMoveToPositionAllowed\", error as string);\n\t\t\tallowed = true;\n\t\t}\n\n\t\treturn allowed;\n\t}\n\n\t/**\n\t * Checks is drop \"between\" is allowed by custom logic for a given targetContext.\n\t * @param customFunction\n\t * @param draggedContext\n\t * @param targetContext\n\t * @returns True if allowed\n\t */\n\tprivate isDropBetweenAllowedForDrag(\n\t\tcustomFunction: (context: Context, parent: Context | null) => boolean,\n\t\tdraggedContext: Context,\n\t\ttargetContext: Context\n\t): boolean {\n\t\tlet isAllowed = true;\n\n\t\t// Determine what to do if we drop before targetContext\n\t\tconst contextBefore = this.getContextBefore(targetContext);\n\t\tconst parentBefore = contextBefore === null ? null : contextBefore.getParent();\n\t\tconst paramsBefore = this.getDropBetweenParameters(contextBefore, parentBefore, targetContext, targetContext.getParent());\n\n\t\t// Determine what to do if we drop after targetContext\n\t\tconst contextAfter = this.getContextAfter(targetContext);\n\t\tconst parentAfter = contextAfter === null ? null : contextAfter.getParent();\n\t\tconst paramsAfter = this.getDropBetweenParameters(targetContext, targetContext.getParent(), contextAfter, parentAfter);\n\n\t\t// If paramsBefore or paramsAfter cannot be determined (because parents are not loaded), we allow drop between and do the real check in onDropDocument\n\t\tif (paramsBefore !== undefined && paramsAfter !== undefined) {\n\t\t\tif (paramsBefore.parent === paramsAfter.parent) {\n\t\t\t\t// Dropping before or after will move under the same parent --> we call the custom logic only once\n\t\t\t\tisAllowed = this.safeIsMoveAllowed(customFunction, draggedContext, paramsBefore.parent);\n\t\t\t} else {\n\t\t\t\t// As the MDC table cannot disable drop before and after separately, we disable drop between only if both drop before and after are forbidden\n\t\t\t\tisAllowed =\n\t\t\t\t\tthis.safeIsMoveAllowed(customFunction, draggedContext, paramsBefore.parent) ||\n\t\t\t\t\tthis.safeIsMoveAllowed(customFunction, draggedContext, paramsAfter.parent);\n\t\t\t}\n\t\t}\n\n\t\treturn isAllowed;\n\t}\n\n\t/**\n\t * Returns the context that is placed before a given context in a ListBinding.\n\t * @param context\n\t * @returns The context before, or null\n\t */\n\tprivate getContextBefore(context: Context): Context | null {\n\t\tconst contextIndex = context.getIndex();\n\t\tif (contextIndex === undefined) {\n\t\t\tthrow new Error(\"Unexpected error\");\n\t\t}\n\n\t\tconst listBinding = context.getBinding() as ODataListBinding;\n\t\treturn contextIndex === 0\n\t\t\t? null\n\t\t\t: listBinding.getAllCurrentContexts().find((ctx) => {\n\t\t\t\t\treturn ctx.getIndex() === contextIndex - 1;\n\t\t\t  }) ?? null;\n\t}\n\n\t/**\n\t * Returns the context that is placed after a given context in a ListBinding.\n\t * @param context\n\t * @returns The context after, or null\n\t */\n\tprivate getContextAfter(context: Context): Context | null {\n\t\tconst contextIndex = context.getIndex();\n\t\tif (contextIndex === undefined) {\n\t\t\tthrow new Error(\"Unexpected error\");\n\t\t}\n\n\t\tconst listBinding = context.getBinding() as ODataListBinding;\n\t\treturn (\n\t\t\tlistBinding.getAllCurrentContexts().find((ctx) => {\n\t\t\t\treturn ctx.getIndex() === contextIndex + 1;\n\t\t\t}) ?? null\n\t\t);\n\t}\n\n\t/**\n\t * Returns information to perform a drop between 2 nodes: the new parent and the next sibling.\n\t * @param contextBefore Context after which the drop is done\n\t * @param parentBefore Parent of contextBefore (undefined if not known)\n\t * @param contextAfter Context before which the drop is done\n\t * @param parentAfter Parent of contextAfter (undefined if not known)\n\t * @returns The new parent and the next sibling, or undefined if it cannot be determined\n\t */\n\tprivate getDropBetweenParameters(\n\t\tcontextBefore: Context | null,\n\t\tparentBefore: Context | null | undefined,\n\t\tcontextAfter: Context | null,\n\t\tparentAfter: Context | null | undefined\n\t): { parent: Context | null; nextSibling?: Context | null } | undefined {\n\t\tif (contextBefore === null) {\n\t\t\t// Drop before first node --> move as first root node\n\t\t\treturn { parent: null, nextSibling: contextAfter };\n\t\t} else if (contextAfter === null) {\n\t\t\t// Drop after last node --> move as next sibling of the last node\n\t\t\treturn parentBefore !== undefined ? { parent: parentBefore, nextSibling: null } : undefined;\n\t\t} else if (parentAfter === contextBefore) {\n\t\t\t// Drop between a parent and its first child --> move as first child of the parent\n\t\t\treturn { parent: contextBefore, nextSibling: contextAfter };\n\t\t} else if (parentBefore === undefined || parentAfter === undefined) {\n\t\t\t// If one of the parent is not known, we don't know what to do\n\t\t\treturn undefined;\n\t\t} else if (parentBefore === parentAfter) {\n\t\t\t// Drop between 2 siblings\n\t\t\treturn { parent: parentBefore, nextSibling: contextAfter };\n\t\t} else {\n\t\t\t// NodeX\n\t\t\t//  ....\n\t\t\t//     |-- contextBefore\n\t\t\t// contextAfter\n\t\t\t// --> Move as the next sibling of contextBefore\n\t\t\treturn { parent: parentBefore, nextSibling: null };\n\t\t}\n\t}\n\n\t/**\n\t * Internal method to drop a context on or between 2 nodes.\n\t * @param context\n\t * @param info\n\t * @returns The move Promise\n\t */\n\tprivate async dropContext(this: ITableBlock & TableHierarchy, context: Context, info: DropInformation): Promise<void> {\n\t\tconst isMoveAllowedInfo = this.getTableDefinition().control.isMoveToPositionAllowed;\n\t\tconst customFunction = isMoveAllowedInfo\n\t\t\t? FPMHelper.getCustomFunction<(node: Context, parent: Context | null) => boolean>(\n\t\t\t\t\tisMoveAllowedInfo.moduleName,\n\t\t\t\t\tisMoveAllowedInfo.methodName,\n\t\t\t\t\tthis.getContent()\n\t\t\t  )\n\t\t\t: undefined;\n\t\tconst internalModelContext = this.getContent().getBindingContext(\"internal\") as InternalModelContext;\n\t\tconst isTableSorted = internalModelContext.getProperty(\"isSorted\") === true;\n\n\t\tconst moveContext = async (parent: Context | null, nextSibling?: Context | null): Promise<void> => {\n\t\t\t// We check if the move is allowed by custom logic (if any), as this check might\n\t\t\t// not have been done in onDragEnterDocument if the parent was not loaded yet.\n\t\t\tif (this.safeIsMoveAllowed(customFunction, context, parent)) {\n\t\t\t\t// If the table is sorted, we ignore the sibling as the position shall be determined by the server\n\t\t\t\treturn context.move({ parent, nextSibling: isTableSorted ? undefined : nextSibling });\n\t\t\t} else {\n\t\t\t\tMessageToast.show(this.getTranslatedText(\"M_TABLE_DROP_NOT_ALLOWED\"));\n\t\t\t}\n\t\t};\n\n\t\tif (info.position === DropPosition.On) {\n\t\t\t// Drop on a node\n\t\t\treturn moveContext(info.parentContext);\n\t\t} else {\n\t\t\t// Drop between 2 nodes\n\t\t\tconst [parentBefore, parentAfter] = await Promise.all([\n\t\t\t\tinfo.contextBefore?.requestParent() ?? null,\n\t\t\t\tinfo.contextAfter?.requestParent() ?? null\n\t\t\t]);\n\t\t\tconst params = this.getDropBetweenParameters(info.contextBefore, parentBefore, info.contextAfter, parentAfter)!;\n\t\t\treturn moveContext(params.parent, params.nextSibling);\n\t\t}\n\t}\n}\n"],"mappings":"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","ignoreList":[]}